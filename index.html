<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Champ de Liénard-Wiechert : Induction et Rayonnement</title>
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        canvas { display: block; }
        
        #controls { 
            position: absolute; top: 10px; left: 10px; 
            background: rgba(30, 30, 30, 0.95); padding: 12px; 
            border: 1px solid #666; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            width: 330px; z-index: 10;
            max-height: 95vh; overflow-y: auto;
            font-size: 12px;
            scrollbar-width: thin; scrollbar-color: #555 #222;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: #222; }
        #controls::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }

        #equation-box {
            margin-bottom: 15px; padding: 8px 5px;
            background: rgba(0, 0, 0, 0.4); border: 1px solid #444; border-radius: 6px;
            text-align: center; color: #ddd;
        }

        h3 { margin-top: 0; margin-bottom: 10px; color: #eee; font-size: 15px; text-align: center; line-height: 1.4; }
        hr { border: 0; border-top: 1px solid #555; margin: 10px 0; }

        input[type=range] { vertical-align: middle; cursor: pointer; width: 100%; margin: 5px 0; }
        label { color: #ccc; cursor: pointer; }
        .group-box { margin-top: 8px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px; border: 1px solid #444; }
        .sub-group { margin-left: 15px; border-left: 2px solid #555; padding-left: 5px; margin-top: 2px; }
        .row { display: flex; align-items: center; margin-bottom: 3px; position: relative; }
        input[type=checkbox] { margin-right: 6px; transform: scale(1.0); cursor: pointer; }
        .dot { height: 8px; width: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; flex-shrink: 0; }
        .bar { height: 3px; width: 20px; display: inline-block; margin-right: 8px; border-radius: 2px; }
        .val { color: #fff; font-weight: bold; }
        mjx-container { font-size: 90% !important; color: #eee !important; overflow-x: hidden; margin: 5px 0 !important; }

        .info-label { border-bottom: 1px dotted #888; cursor: help; }
        .tooltip {
            visibility: hidden; width: 260px; background-color: #1a1a1a; color: #eee; text-align: left; 
            border-radius: 6px; padding: 12px; position: absolute; z-index: 100; top: 100%; left: 10px; 
            margin-top: 5px; border: 1px solid #444; border-left: 3px solid #00aaff;
            box-shadow: 0 5px 20px rgba(0,0,0,0.9); opacity: 0; transition: opacity 0.3s; 
            font-size: 11px; line-height: 1.5; pointer-events: none;
        }
        .row:hover .tooltip { visibility: visible; opacity: 1; }
        .tooltip strong { color: #00aaff; display: block; margin-bottom: 5px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 3px; }
        .tooltip em { color: #aaa; display: block; margin-top: 5px; font-style: italic; }
        
        .disabled-section { opacity: 0.3; pointer-events: none; transition: opacity 0.3s; }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Champ de Liénard-Wiechert :<br>Induction et Rayonnement</h3>
        
        <div id="equation-box">
            $$ \vec{E} = \underbrace{\color{#00ff00}{ \frac{q (\vec{n} - \vec{\beta})}{4\pi\epsilon_0 \gamma^2 \kappa^3 R^2} }}_{\text{Coulomb}} + \underbrace{\color{#ff3333}{ \frac{q \vec{n} \times [(\vec{n} - \vec{\beta}) \times \dot{\vec{\beta}}]}{4\pi\epsilon_0 c \kappa^3 R} }}_{\text{Rayonnement}} $$
        </div>
        
        <hr>

        <label for="rSlider" style="color:#ffcc00;">Zoom / Rayon de l'anneau : <span id="rValue" class="val">150</span></label><br>
        <input type="range" id="rSlider" min="15" max="200" step="5" value="150">
        
        <label for="betaSlider" style="margin-top:5px; display:block;">Vitesse des charges (&beta;=v/c) : <span id="betaValue" class="val">0.30</span></label>
        <input type="range" id="betaSlider" min="0.1" max="0.95" step="0.01" value="0.30">
        
        <label for="nSlider" style="margin-top:2px; display:block;">Nombre de charges : <span id="nValue" class="val">150</span></label>
        <input type="range" id="nSlider" min="1" max="350" value="150">

        <hr>
        <div style="font-weight:bold; color:#eee; margin-bottom:5px; text-align:center;">MODES DE VISUALISATION</div>

        <div class="group-box" style="border: 1px solid #ffcc00; background:rgba(50,50,0,0.3);">
            <div class="row">
                <input type="checkbox" id="chkPauseTrace">
                <label for="chkPauseTrace" style="color:#ffcc00; font-weight:bold;">Visualiser les lignes de champ</label>
            </div>
            <div style="font-size:10px; color:#aaa; margin-left:20px;">(Pause l'animation pour le calcul)</div>
        </div>

        <div class="group-box" id="boxFieldMap" style="border: 1px solid #aaa; margin-top:5px;">
            <div class="row">
                <input type="checkbox" id="chkFieldMap">
                <label for="chkFieldMap" style="color:#ccc; font-weight:bold;">Carte du champ électrique</label>
            </div>
        </div>

        <div id="mouseSection">
            <hr>
            <div style="font-weight:bold; color:#bbb; margin-bottom:3px; text-align:center;">Analyse à la Souris</div>
            
            <div class="group-box">
                <div style="font-weight:bold; color:#bbb; margin-bottom:3px;">Position des charges :</div>
                
                <div class="row">
                    <input type="checkbox" id="chkShowReal" checked>
                    <span class="dot" style="background:#888;"></span>
                    <label for="chkShowReal" class="info-label">Réelle (t)</label>
                    <div class="tooltip">
                        <strong>Charge Réelle (Présent)</strong>
                        Position physique exacte de la particule à l'instant actuel $t$.<br>
                        <em>Note : L'information que la particule est ici n'a pas encore eu le temps d'arriver à l'observateur.</em>
                    </div>
                </div>
                
                <div class="row">
                    <input type="checkbox" id="chkShowRetarded">
                    <span class="dot" style="background:cyan;"></span>
                    <label for="chkShowRetarded" class="info-label">Retardée (t')</label>
                    <div class="tooltip">
                        <strong>Charge Retardée (Passé)</strong>
                        Position de la particule au temps passé $t' = t - R/c$.<br>
                        C'est de cet endroit qu'est partie l'onde électromagnétique que l'observateur reçoit maintenant. C'est la "source" réelle du champ.
                    </div>
                </div>
                
                <div class="row">
                    <input type="checkbox" id="chkShowVirtual" checked>
                    <span class="dot" style="background:magenta;"></span>
                    <label for="chkShowVirtual" class="info-label">Virtuelle</label>
                    <div class="tooltip">
                        <strong>Charge Virtuelle (Extrapolée)</strong>
                        Position qu'aurait la charge <strong>maintenant</strong> si elle avait continué tout droit à vitesse constante depuis l'émission.<br>
                        <em>Physique : Le champ électrique "proche" (Coulomb) pointe vers cette position, créant l'illusion que le champ anticipe le mouvement.</em>
                    </div>
                </div>
            </div>

            <div id="vectorOptions">
                <div class="group-box" style="border-left: 3px solid #00ff00;">
                    <div style="font-weight:bold; color:#ccffcc;">Terme Coulomb (1/R²)</div>
                    <div class="sub-group">
                        <div class="row"><input type="checkbox" id="chkCoulombRad" checked><span class="bar" style="background: #00ff00;"></span><label>Radiale</label></div>
                        <div class="row"><input type="checkbox" id="chkCoulombOrtho" checked><span class="bar" style="background: #66ff66; opacity:0.7;"></span><label>Orthoradiale</label></div>
                    </div>
                </div>
                <div class="group-box" style="border-left: 3px solid #ff3333;">
                    <div style="font-weight:bold; color:#ffcccc;">Terme Rayonnement (1/R)</div>
                    <div class="sub-group">
                        <div class="row"><input type="checkbox" id="chkRadRad" checked><span class="bar" style="background: #ff3333;"></span><label>Radiale</label></div>
                        <div class="row"><input type="checkbox" id="chkRadOrtho" checked><span class="bar" style="background: #ff8888; opacity:0.7;"></span><label>Orthoradiale</label></div>
                    </div>
                </div>
                <div class="group-box">
                     <div class="row"><span class="bar" style="background: #ffff00; height:4px;"></span><label style="color: #ffff00;">Champ Total E</label></div>
                    <div class="row" style="margin-top:5px; border-top:1px solid #555; padding-top:5px;">
                        <input type="checkbox" id="chkShowTrail" checked>
                        <label for="chkShowTrail" style="font-style:italic;">Afficher la trace (Hodographe)</label>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="simCanvas"></canvas>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const nSlider = document.getElementById('nSlider');
    const nValue = document.getElementById('nValue');
    const betaSlider = document.getElementById('betaSlider');
    const betaValue = document.getElementById('betaValue');
    const rSlider = document.getElementById('rSlider');
    const rValue = document.getElementById('rValue');
    const mouseSection = document.getElementById('mouseSection');
    
    const chkPauseTrace = document.getElementById('chkPauseTrace');
    const chkFieldMap = document.getElementById('chkFieldMap');
    const boxFieldMap = document.getElementById('boxFieldMap'); 

    const chkCoulombRad = document.getElementById('chkCoulombRad');
    const chkCoulombOrtho = document.getElementById('chkCoulombOrtho');
    const chkRadRad = document.getElementById('chkRadRad');
    const chkRadOrtho = document.getElementById('chkRadOrtho');
    const chkShowReal = document.getElementById('chkShowReal');
    const chkShowRetarded = document.getElementById('chkShowRetarded');
    const chkShowVirtual = document.getElementById('chkShowVirtual');
    const chkShowTrail = document.getElementById('chkShowTrail'); 

    let width, height;

    const c = 6;            
    let R_ring = 150; // Initialisé à 150
    const K_BASE_REF = 4000;
    const amp = 0.25; 

    let freq = 0.03; 
    let targetBeta = 0.30; 

    let mouse = { x: 0, y: 0 };
    let N = 150; 
    let particles = [];
    let histories = []; 
    const MAX_HISTORY = 600; 
    let globalTime = 0;
    
    let vectorTrail = []; 
    const MAX_TRAIL_LENGTH = 150; 

    let lineSeeds = [];

    function initParticles() {
        particles = []; histories = []; vectorTrail = [];
        for(let i=0; i<N; i++) {
            let baseAngle = (Math.PI * 2 * i) / N;
            particles.push({ baseAngle: baseAngle, phaseOffset: 0, x: 0, y: 0, vx: 0, vy: 0, ax: 0, ay: 0 });
            histories.push([]); 
        }
    }

    function initLineSeeds() {
        lineSeeds = [];
        const cols = 25; 
        const rows = 20;
        for(let i=0; i<cols; i++) {
            for(let j=0; j<rows; j++) {
                let jx = (Math.random()-0.5) * 40;
                let jy = (Math.random()-0.5) * 40;
                lineSeeds.push({
                    x: (i/cols - 0.5) * width * 1.4 + jx,
                    y: (j/rows - 0.5) * height * 1.4 + jy
                });
            }
        }
    }

    function updateFreq() { freq = (targetBeta * c) / (R_ring * amp); }

    nSlider.addEventListener('input', function() { N = parseInt(this.value); nValue.textContent = N; initParticles(); });
    betaSlider.addEventListener('input', function() { targetBeta = parseFloat(this.value); betaValue.textContent = targetBeta.toFixed(2); updateFreq(); });
    
    rSlider.addEventListener('input', function() {
        R_ring = parseInt(this.value);
        rValue.textContent = R_ring;
        updateFreq(); 
    });

    function updateUIVisibility() {
        if(chkPauseTrace.checked) {
            boxFieldMap.classList.add('disabled-section');
            chkFieldMap.disabled = true; 
            mouseSection.classList.add('disabled-section'); 
        } 
        else {
            boxFieldMap.classList.remove('disabled-section');
            chkFieldMap.disabled = false;
            
            if(chkFieldMap.checked) {
                mouseSection.classList.add('disabled-section');
            } else {
                mouseSection.classList.remove('disabled-section');
            }
        }
    }
    
    chkPauseTrace.addEventListener('change', updateUIVisibility);
    chkFieldMap.addEventListener('change', updateUIVisibility);
    updateUIVisibility();

    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        initLineSeeds();
    }
    window.addEventListener('resize', resize); resize();

    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left - width / 2;
        mouse.y = e.clientY - rect.top - height / 2;
        vectorTrail = []; 
    });

    updateFreq(); initParticles(); initLineSeeds();

    function updatePhysics() {
        globalTime++;
        for(let i=0; i<N; i++) {
            let p = particles[i];
            let phase = globalTime * freq + p.phaseOffset;
            let theta = p.baseAngle + amp * Math.sin(phase);
            let thetaDot = amp * freq * Math.cos(phase);
            let thetaDotDot = -amp * freq * freq * Math.sin(phase);
            let cosT = Math.cos(theta); let sinT = Math.sin(theta);
            
            p.x = R_ring * cosT; p.y = R_ring * sinT;
            p.vx = -R_ring * sinT * thetaDot; p.vy =  R_ring * cosT * thetaDot;
            p.ax = -R_ring * (cosT * thetaDot * thetaDot + sinT * thetaDotDot);
            p.ay =  R_ring * (-sinT * thetaDot * thetaDot + cosT * thetaDotDot);

            histories[i].unshift({ x: p.x, y: p.y, vx: p.vx, vy: p.vy, ax: p.ax, ay: p.ay, t: globalTime });
            if (histories[i].length > MAX_HISTORY) histories[i].pop();
        }
    }

    function sub(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
    function mag(v) { return Math.sqrt(v.x * v.x + v.y * v.y); }
    function normalize(v) { let m = mag(v); return m === 0 ? {x:0, y:0} : { x: v.x/m, y: v.y/m }; }
    function dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }

    function getRetardedState(particleIndex, obsX, obsY) {
        let hist = histories[particleIndex];
        if (!hist || hist.length === 0) return null;
        let searchLimit = Math.min(hist.length, 600);
        for (let k = 0; k < searchLimit; k++) {
            let s = hist[k];
            let dx = obsX - s.x; let dy = obsY - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (Math.abs(dist - k * c) < c) return { state: s, R: dist, vectorR: {x: dx, y: dy} };
        }
        return null;
    }

    function computeFieldAt(x, y) {
        let res = { total: {x:0, y:0}, coulomb: {x:0, y:0}, rad: {x:0, y:0}, count: 0 };
        let gammaApprox = 1 / Math.sqrt(1 - targetBeta*targetBeta);
        
        let zoomFactor = 150 / R_ring; 
        let visualK = K_BASE_REF * zoomFactor * 1.5 / (gammaApprox * 0.5 + 0.5); 

        for(let i=0; i<N; i++) {
            let ret = getRetardedState(i, x, y);
            if (ret) {
                res.count++;
                let s = ret.state; let R = ret.R; let n = normalize(ret.vectorR);
                let beta = { x: s.vx / c, y: s.vy / c }; let betaDot = { x: s.ax / c, y: s.ay / c }; 
                let kappa = 1 - dot(n, beta); if(kappa < 0.01) kappa = 0.01;

                let n_minus_beta = sub(n, beta);
                let coeff1 = visualK / (Math.pow(kappa, 3) * Math.pow(R, 2));
                let cx = n_minus_beta.x * coeff1; let cy = n_minus_beta.y * coeff1;

                let term2Vec = { x: 0, y: 0 };
                let AC = dot(n, betaDot); let AB = dot(n, n_minus_beta);
                term2Vec.x = n_minus_beta.x * AC - betaDot.x * AB;
                term2Vec.y = n_minus_beta.y * AC - betaDot.y * AB;
                let coeff2 = visualK / (c * Math.pow(kappa, 3) * R);
                let rx = term2Vec.x * coeff2; let ry = term2Vec.y * coeff2;

                res.coulomb.x += cx; res.coulomb.y += cy;
                res.rad.x += rx; res.rad.y += ry;
                res.total.x += (cx + rx); res.total.y += (cy + ry);
            }
        }
        return res;
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, lineWidth, opacity = 1.0) {
        if (!isFinite(toX) || !isFinite(toY)) return;
        const dx = toX - fromX; const dy = toY - fromY;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len < 2) return;
        const headLength = 8 + lineWidth; const angle = Math.atan2(dy, dx); const headAngle = Math.PI / 9; 
        
        ctx.save(); ctx.globalAlpha = opacity; ctx.strokeStyle = color; ctx.fillStyle = color;
        ctx.lineWidth = lineWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - headAngle), toY - headLength * Math.sin(angle - headAngle));
        ctx.lineTo(toX - headLength * Math.cos(angle + headAngle), toY - headLength * Math.sin(angle + headAngle));
        ctx.closePath(); ctx.fill(); ctx.restore();
    }

    function drawContinuousStreamlines() {
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = 'rgba(255, 230, 150, 0.6)'; 
        
        const MAX_STEPS = 200; 
        const STEP_SIZE = 8;   

        ctx.beginPath();

        for (let seed of lineSeeds) {
            let pointsForward = [];
            let cx = seed.x, cy = seed.y;
            pointsForward.push({x: cx, y: cy});

            for(let k=0; k<MAX_STEPS; k++) {
                let field = computeFieldAt(cx, cy);
                if(field.count === 0) break;
                
                let fx = field.total.x; let fy = field.total.y;
                let mag = Math.sqrt(fx*fx + fy*fy);
                if(mag < 0.0001) break;

                cx += (fx / mag) * STEP_SIZE;
                cy += (fy / mag) * STEP_SIZE;

                if(Math.abs(cx) > width/1.6 || Math.abs(cy) > height/1.6) break; 
                let distCenter = Math.sqrt(cx*cx + cy*cy);
                if(distCenter > R_ring - 15 && distCenter < R_ring + 15) break; 

                pointsForward.push({x: cx, y: cy});
            }

            let pointsBackward = [];
            cx = seed.x; cy = seed.y;
            
            for(let k=0; k<MAX_STEPS; k++) {
                let field = computeFieldAt(cx, cy);
                if(field.count === 0) break;
                
                let fx = field.total.x; let fy = field.total.y;
                let mag = Math.sqrt(fx*fx + fy*fy);
                if(mag < 0.0001) break;

                cx -= (fx / mag) * STEP_SIZE;
                cy -= (fy / mag) * STEP_SIZE;

                if(Math.abs(cx) > width/1.6 || Math.abs(cy) > height/1.6) break;
                let distCenter = Math.sqrt(cx*cx + cy*cy);
                if(distCenter > R_ring - 15 && distCenter < R_ring + 15) break;

                pointsBackward.push({x: cx, y: cy});
            }

            if(pointsBackward.length > 0) {
                let start = pointsBackward[pointsBackward.length-1];
                ctx.moveTo(start.x, start.y);
                for(let i=pointsBackward.length-2; i>=0; i--) {
                    ctx.lineTo(pointsBackward[i].x, pointsBackward[i].y);
                }
                ctx.lineTo(seed.x, seed.y); 
            } else {
                ctx.moveTo(seed.x, seed.y);
            }

            for(let i=1; i<pointsForward.length; i++) {
                ctx.lineTo(pointsForward[i].x, pointsForward[i].y);
            }
        }
        ctx.stroke();
    }

    function draw() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillRect(0, 0, width, height);
        ctx.save(); ctx.translate(width / 2, height / 2);
        
        if (!chkPauseTrace.checked) {
            updatePhysics();
        }

        ctx.globalAlpha = 1.0; ctx.setLineDash([]);

        let oscAngle = amp * Math.sin(globalTime * freq);
        ctx.beginPath();
        let bx = R_ring * Math.cos(oscAngle); let by = R_ring * Math.sin(oscAngle);
        ctx.moveTo(-bx, -by); ctx.lineTo(bx, by);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 4; ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fillStyle = '#FFF'; ctx.fill();

        if ((chkShowReal.checked || chkShowRetarded.checked || chkShowVirtual.checked)) {
            for(let i=0; i<N; i++) {
                let p = particles[i];
                if(chkShowReal.checked) {
                    ctx.fillStyle = '#666'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
                }
                
                if(!chkFieldMap.checked) {
                    if(chkShowRetarded.checked || chkShowVirtual.checked) {
                        let refX = chkFieldMap.checked ? 0 : mouse.x;
                        let refY = chkFieldMap.checked ? 0 : mouse.y;
                        let ret = getRetardedState(i, refX, refY);
                        if(ret) {
                            if(chkShowRetarded.checked) {
                                ctx.fillStyle = 'cyan'; ctx.beginPath(); ctx.arc(ret.state.x, ret.state.y, 2, 0, Math.PI*2); ctx.fill();
                            }
                            if(chkShowVirtual.checked) {
                                let dt = ret.R / c;
                                let virX = ret.state.x + ret.state.vx * dt;
                                let virY = ret.state.y + ret.state.vy * dt;
                                ctx.fillStyle = 'magenta'; ctx.beginPath(); ctx.arc(virX, virY, 1.5, 0, Math.PI*2); ctx.fill();
                            }
                        }
                    }
                }
            }
        }

        if (chkPauseTrace.checked) {
            drawContinuousStreamlines();
        }

        else if (chkFieldMap.checked) {
            const step = 40; 
            const startX = -Math.floor(width/2 / step) * step; const endX = Math.ceil(width/2 / step) * step;
            const startY = -Math.floor(height/2 / step) * step; const endY = Math.ceil(height/2 / step) * step;

            for (let x = startX; x <= endX; x += step) {
                for (let y = startY; y <= endY; y += step) {
                    let field = computeFieldAt(x, y);
                    if (field.count > 0) {
                        let vx = field.total.x; let vy = field.total.y;
                        let mag = Math.sqrt(vx*vx + vy*vy);
                        if (mag > 0.0001) {
                            let intensity = Math.log(mag * 300 + 1) / 4; 
                            if(intensity > 1) intensity = 1;
                            let hue = 240 - intensity * 180; 
                            let light = 30 + intensity * 60;
                            let col = `hsl(${hue}, 100%, ${light}%)`;
                            let len = 15; let dx = (vx/mag) * len; let dy = (vy/mag) * len;
                            
                            ctx.strokeStyle = col; ctx.lineWidth = 1.5;
                            ctx.beginPath(); ctx.moveTo(x - dx/2, y - dy/2); ctx.lineTo(x + dx/2, y + dy/2);
                            ctx.lineTo(x + dx/2 - 4 * (dx/len * Math.cos(Math.PI/6) + dy/len * Math.sin(Math.PI/6)), 
                                       y + dy/2 - 4 * (dy/len * Math.cos(Math.PI/6) - dx/len * Math.sin(Math.PI/6)));
                            ctx.stroke();
                        }
                    }
                }
            }
        } 
        
        else {
            let field = computeFieldAt(mouse.x, mouse.y);
            if (field.count > 0) {
                let mouseDist = Math.sqrt(mouse.x*mouse.x + mouse.y*mouse.y);
                let u_r = { x: 0, y: 0 }; let u_theta = { x: 0, y: 0 };
                if (mouseDist > 0.1) {
                    u_r.x = mouse.x / mouseDist; u_r.y = mouse.y / mouseDist;
                    u_theta.x = -u_r.y; u_theta.y = u_r.x;
                }

                let scaleFactor = N > 10 ? Math.sqrt(10/N) : 1; 
                let displayScale = 40 * scaleFactor; let maxLen = 500;

                let C_rad_val = dot(field.coulomb, u_r); let C_orth_val = dot(field.coulomb, u_theta);
                let v_C_rad = { x: C_rad_val * u_r.x * displayScale, y: C_rad_val * u_r.y * displayScale };
                let v_C_orth = { x: C_orth_val * u_theta.x * displayScale, y: C_orth_val * u_theta.y * displayScale };

                let R_rad_val = dot(field.rad, u_r); let R_orth_val = dot(field.rad, u_theta);
                let v_R_rad = { x: R_rad_val * u_r.x * displayScale, y: R_rad_val * u_r.y * displayScale };
                let v_R_orth = { x: R_orth_val * u_theta.x * displayScale, y: R_orth_val * u_theta.y * displayScale };

                function clamp(v) { let l = Math.sqrt(v.x**2 + v.y**2); if(l > maxLen) { v.x *= maxLen/l; v.y *= maxLen/l; } return v; }
                clamp(v_C_rad); clamp(v_C_orth); clamp(v_R_rad); clamp(v_R_orth);

                if (chkCoulombRad.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_C_rad.x, mouse.y + v_C_rad.y, '#00ff00', 1.5, 0.9);
                if (chkCoulombOrtho.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_C_orth.x, mouse.y + v_C_orth.y, '#66ff66', 1.5, 0.9);
                if (chkRadRad.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_R_rad.x, mouse.y + v_R_rad.y, '#ff3333', 1.5, 0.9);
                if (chkRadOrtho.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_R_orth.x, mouse.y + v_R_orth.y, '#ff8888', 1.5, 0.9);

                let v_sum = { x: 0, y: 0 };
                if (chkCoulombRad.checked) { v_sum.x += v_C_rad.x; v_sum.y += v_C_rad.y; }
                if (chkCoulombOrtho.checked) { v_sum.x += v_C_orth.x; v_sum.y += v_C_orth.y; }
                if (chkRadRad.checked) { v_sum.x += v_R_rad.x; v_sum.y += v_R_rad.y; }
                if (chkRadOrtho.checked) { v_sum.x += v_R_orth.x; v_sum.y += v_R_orth.y; }
                
                let vSumLen = Math.sqrt(v_sum.x**2 + v_sum.y**2);
                let anyChecked = chkCoulombRad.checked || chkCoulombOrtho.checked || chkRadRad.checked || chkRadOrtho.checked;

                if (anyChecked && vSumLen > 0.001) {
                    if (chkShowTrail.checked) {
                        vectorTrail.push({x: mouse.x + v_sum.x, y: mouse.y + v_sum.y});
                        if (vectorTrail.length > MAX_TRAIL_LENGTH) vectorTrail.shift();
                        ctx.beginPath();
                        for(let k=0; k<vectorTrail.length - 1; k++) {
                            ctx.moveTo(vectorTrail[k].x, vectorTrail[k].y);
                            ctx.lineTo(vectorTrail[k+1].x, vectorTrail[k+1].y);
                        }
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)'; ctx.lineWidth = 1; ctx.stroke();
                    }

                    if (vSumLen > 15) {
                        drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_sum.x, mouse.y + v_sum.y, '#ffff00', 2, 1.0);
                    } else {
                        let dirX = v_sum.x / vSumLen; let dirY = v_sum.y / vSumLen;
                        ctx.save(); ctx.beginPath(); ctx.setLineDash([5, 5]);
                        ctx.moveTo(mouse.x, mouse.y); ctx.lineTo(mouse.x + dirX * 60, mouse.y + dirY * 60);
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
                    }
                }
            }
        }

        ctx.restore();
        requestAnimationFrame(draw);
    }

    draw();
</script>
</body>
</html>
