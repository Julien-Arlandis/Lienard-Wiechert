<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Heaviside-Feynman v7.1</title>
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        canvas { display: block; cursor: crosshair; }
        
        #controls { 
            position: absolute; top: 10px; left: 10px; 
            width: 360px; 
            z-index: 10;
            transition: transform 0.3s ease-in-out;
            overflow: visible; 
            pointer-events: none;
        }
        #controls.collapsed { transform: translateX(-380px); }

        #panel-content {
            background: rgba(20, 20, 20, 0.95); 
            padding: 12px; 
            border: 1px solid #555; 
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.9);
            max-height: 90vh; 
            overflow-y: auto;
            pointer-events: auto;
            font-size: 12px;
            scrollbar-width: thin; scrollbar-color: #555 #222;
            position: relative;
        }

        #zoom-controls {
            position: absolute; top: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 5px;
            z-index: 20;
        }
        .zoom-btn {
            width: 40px; height: 40px;
            background: rgba(50, 50, 50, 0.8);
            color: white; border: 1px solid #777; border-radius: 50%;
            font-size: 24px; font-weight: bold; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.2s; user-select: none;
        }
        .zoom-btn:hover { background: #00aaff; border-color: #fff; }
        .zoom-btn:active { transform: scale(0.95); }

        #scope-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 320px; height: 180px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #555; border-radius: 8px;
            box-shadow: 0 0 25px rgba(0,0,0,0.8);
            z-index: 20; pointer-events: none;
            display: none; 
            flex-direction: column;
        }
        #scope-header {
            background: #222; color: #ccc; padding: 5px 10px; font-size: 11px;
            border-bottom: 1px solid #555; border-radius: 6px 6px 0 0;
            display: flex; justify-content: space-between; align-items: center;
        }
        #scopeCanvas { width: 100%; height: 100%; border-radius: 0 0 6px 6px; }
        .legend-item { display: inline-block; margin-left: 10px; font-weight: bold; font-family: monospace; font-size: 12px; }

        .version-tag {
            position: absolute; top: 8px; right: 12px;
            font-family: monospace; font-size: 10px; color: #aaa; pointer-events: none;
        }

        #toggle-btn {
            position: absolute; top: 0; right: -32px; width: 32px; height: 32px;
            background: #333; color: #fff; border: 1px solid #555; border-left: none;
            border-radius: 0 6px 6px 0; cursor: pointer; pointer-events: auto;
            display: flex; align-items: center; justify-content: center; font-size: 16px;
        }
        #toggle-btn:hover { background: #444; color: #00aaff; }

        #panel-content::-webkit-scrollbar { width: 8px; }
        #panel-content::-webkit-scrollbar-track { background: #222; border-radius: 4px; }
        #panel-content::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }

        #equation-box {
            margin-bottom: 15px; padding: 10px 5px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid #444; border-radius: 6px;
            text-align: center; color: #ddd;
        }
        .eq-title { font-weight:bold; color:#aaa; font-size:10px; margin-top:8px; margin-bottom:2px; text-transform:uppercase; letter-spacing:1px; }
        .eq-sep { margin: 8px 0; border-top: 1px dashed #444; }

        h3 { margin-top: 0; margin-bottom: 10px; color: #eee; font-size: 15px; text-align: center; line-height: 1.4; margin-right: 20px; }
        hr { border: 0; border-top: 1px solid #555; margin: 10px 0; }

        input[type=range] { vertical-align: middle; cursor: pointer; width: 100%; margin: 5px 0; }
        label { color: #ccc; cursor: pointer; }
        .group-box { margin-top: 8px; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 5px; border: 1px solid #444; }
        .sub-group { margin-left: 15px; border-left: 2px solid #555; padding-left: 5px; margin-top: 2px; }
        .row { display: flex; align-items: center; margin-bottom: 3px; position: relative; }
        input[type=checkbox], input[type=radio] { margin-right: 6px; transform: scale(1.0); cursor: pointer; }
        .dot { height: 8px; width: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; flex-shrink: 0; }
        .bar { height: 3px; width: 20px; display: inline-block; margin-right: 8px; border-radius: 2px; }
        .val { color: #fff; font-weight: bold; }
        mjx-container { font-size: 85% !important; color: #eee !important; overflow-x: hidden; margin: 2px 0 !important; }

        .info-label { cursor: help; }
        .tooltip {
            visibility: hidden; width: 260px; background-color: #111; color: #eee; text-align: left; 
            border-radius: 6px; padding: 12px; position: absolute; z-index: 100; top: 100%; left: 10px; 
            margin-top: 5px; border: 1px solid #444; border-left: 3px solid #00aaff;
            box-shadow: 0 5px 20px rgba(0,0,0,1); opacity: 0; transition: opacity 0.3s; 
            font-size: 11px; line-height: 1.5; pointer-events: none;
        }
        .row:hover .tooltip { visibility: visible; opacity: 1; }
        .tooltip strong { color: #00aaff; display: block; margin-bottom: 5px; font-size: 12px; padding-bottom: 0px; }
        .tooltip em { color: #aaa; display: block; margin-top: 5px; font-style: italic; }
        
        .disabled-section { opacity: 0.3; pointer-events: none; transition: opacity 0.3s; }
        .radio-group { display: flex; justify-content: space-around; margin-top: 5px; }

        .icon-inline { display: inline-block; vertical-align: middle; margin-left: 5px; }
        .label-with-icon { display: flex; align-items: center; font-weight: bold; }
    </style>
</head>
<body>
    <div id="zoom-controls">
        <div class="zoom-btn" id="btnZoomIn" title="Zoomer (Agrandir)">+</div>
        <div class="zoom-btn" id="btnZoomOut" title="Dézoomer (Réduire)">-</div>
    </div>

    <div id="controls">
        <button id="toggle-btn" title="Réduire/Agrandir le panneau">◀</button>

        <div id="panel-content">
            <div class="version-tag">v7.1</div>

            <h3>Visualisation Relativiste</h3>
            
            <div id="equation-box">
                <div class="eq-title">Formule de Heaviside-Feynman</div>
                $$ E = \frac{q}{4\pi\epsilon_0} \left[ \underbrace{ \color{#00ff00}{ \frac{e_{r'}}{r'^2} + \frac{r'}{c} \frac{d}{dt} \left( \frac{e_{r'}}{r'^2} \right) } }_{\text{Coulomb}} + \underbrace{ \color{#ff3333}{ \frac{1}{c^2} \frac{d^2}{dt^2} e_{r'} } }_{\text{Rayonnement}} \right] $$
            </div>
            
            <hr>
            
            <div style="font-weight:bold; color:#00aaff; margin-bottom:5px;">MODE DE CONTRÔLE</div>
            <div class="group-box" style="background:rgba(0, 170, 255, 0.1); border:1px solid #005588;">
                <div class="radio-group">
                    <div><input type="radio" id="modeAuto" name="modeCtrl" value="auto" checked><label for="modeAuto" style="font-weight:bold;">Auto (Scénario)</label></div>
                    <div><input type="radio" id="modeManual" name="modeCtrl" value="manual"><label for="modeManual" style="font-weight:bold;">Manuel (Souris)</label></div>
                </div>
                <div id="manualHint" style="display:none; margin-top:5px; font-size:11px; color:#aaa; font-style:italic; text-align:center;">
                    Bougez la souris pour créer le champ.
                </div>
            </div>

            <hr>
            
            <div id="autoControls">
                <div style="font-weight:bold; color:#ffaa00; margin-bottom:5px;">GÉOMÉTRIE DES CHARGES</div>
                <div class="group-box" style="background:rgba(255, 170, 0, 0.1); border:1px solid #960;">
                    <div class="radio-group">
                        <div><input type="radio" id="geoRing" name="geometry" value="ring" checked><label for="geoRing" style="font-weight:bold;">Anneau</label></div>
                        <div><input type="radio" id="geoWire" name="geometry" value="wire"><label for="geoWire" style="font-weight:bold;">Fil Rectiligne</label></div>
                    </div>
                </div>
                <hr>
                
                <label for="betaSlider" style="margin-top:5px; display:block;">Vitesse des charges (&beta;) : <span id="betaValue" class="val">0.30</span></label>
                <input type="range" id="betaSlider" min="0.1" max="0.95" step="0.01" value="0.30">
                
                <label for="nSlider" style="margin-top:2px; display:block;">Nombre de charges : <span id="nValue" class="val">150</span></label>
                <input type="range" id="nSlider" min="1" max="350" value="150">
                <hr>
            </div>
            
            <div class="group-box" style="border: 1px solid #aaa; background: rgba(0,0,0,0.5);">
                <div class="row">
                    <input type="checkbox" id="chkShowScope">
                    <label for="chkShowScope" style="font-weight:bold; color: orange;">Afficher l'Oscilloscope</label>
                </div>
            </div>

            <hr>
            <div style="font-weight:bold; color:#eee; margin-bottom:5px; text-align:center;">MODES DE VISUALISATION</div>

            <div class="group-box" id="boxPauseTrace" style="border: 1px solid #ffcc00; background:rgba(50,50,0,0.3);">
                <div class="row"><input type="checkbox" id="chkPauseTrace"><label for="chkPauseTrace" style="color:#ffcc00; font-weight:bold;">Lignes de champ (E)</label></div>
            </div>

            <div class="group-box" id="boxMagneticMap" style="border: 1px solid #aaa; margin-top:5px; background:rgba(0,0,50,0.3);">
                <div class="row">
                    <input type="checkbox" id="chkMagneticMap">
                    <label for="chkMagneticMap" style="color:#ccc;" class="label-with-icon">
                        Carte B
                        <svg class="icon-inline" viewBox="0 0 24 12" style="width:24px; height:12px;">
                            <circle cx="6" cy="6" r="5" fill="rgba(0, 200, 255, 0.8)"/>
                            <circle cx="18" cy="6" r="5" fill="rgba(255, 200, 0, 0.8)"/>
                        </svg>
                    </label>
                </div>
            </div>

            <div class="group-box" id="boxFieldMap" style="border: 1px solid #fff; margin-top:5px;">
                <div class="row">
                    <input type="checkbox" id="chkFieldMap">
                    <label for="chkFieldMap" style="color:#fff;" class="label-with-icon">
                        Carte vectorielle E
                        <svg class="icon-inline" viewBox="0 0 20 10" style="width:20px; height:10px;">
                           <polygon points="0,4 13,4 13,1 20,5 13,9 13,6 0,6" fill="white"/>
                        </svg>
                    </label>
                </div>
            </div>

            <div class="group-box" id="boxPoynting" style="border: 1px solid #0f0; margin-top:5px; background:rgba(0,255,0,0.1);">
                <div class="row">
                    <input type="checkbox" id="chkPoynting">
                    <label for="chkPoynting" style="color:#0f0;" class="label-with-icon">
                        Flux d'Énergie S
                        <svg class="icon-inline" viewBox="0 0 20 10" style="width:20px; height:10px;">
                           <polygon points="0,4 13,4 13,1 20,5 13,9 13,6 0,6" fill="#00ff00"/>
                        </svg>
                    </label>
                </div>
            </div>

            <hr>
            
            <div class="group-box">
                <div style="font-weight:bold; color:#bbb; margin-bottom:3px;">Position des charges :</div>
                <div class="row">
                    <input type="checkbox" id="chkShowReal" checked><span class="dot" style="background:#888;"></span><label for="chkShowReal" class="info-label">Réelle (t)</label>
                    <div class="tooltip">
                        <strong>Charge Réelle (Présent)</strong>
                        Position physique exacte de la particule à l'instant actuel $t$.
                    </div>
                </div>
                <div class="row">
                    <input type="checkbox" id="chkShowRetarded"><span class="dot" style="background:cyan;"></span><label for="chkShowRetarded" class="info-label">Retardée (t')</label>
                    <div class="tooltip">
                        <strong>Charge Retardée (Passé)</strong>
                        Position de la particule au temps passé $t' = t - R/c$.<br>
                        C'est de cet endroit qu'est partie l'onde électromagnétique que l'observateur reçoit à l'instant actuel $t$.
                    </div>
                </div>
                <div class="row">
                    <input type="checkbox" id="chkShowVirtual" checked><span class="dot" style="background:magenta;"></span><label for="chkShowVirtual" class="info-label">Virtuelle</label>
                    <div class="tooltip">
                        <strong>Charge Virtuelle (Extrapolée)</strong>
                        Position qu'aurait la charge à l'instant actuel $t$ si elle avait continué tout droit à vitesse constante.<br>
                        <em>Physique : Le champ électrique "proche" pointe vers cette position.</em>
                    </div>
                </div>
            </div>

            <div id="vectorOptions" style="margin-top:10px;">
                <div style="font-weight:bold; color:#ffffaa; margin-bottom:3px; text-align:center; font-size:11px;">FILTRAGE (E)</div>
                <div class="group-box" style="border-left: 3px solid #00ff00;">
                    <div style="font-weight:bold; color:#ccffcc;">Terme Coulomb (1/R²)</div>
                    <div class="sub-group">
                        <div class="row"><input type="checkbox" id="chkCoulombRad" checked><span class="bar" style="background: #00ff00;"></span><label>Radiale</label></div>
                        <div class="row"><input type="checkbox" id="chkCoulombOrtho" checked><span class="bar" style="background: #66ff66; opacity:0.7;"></span><label>Orthoradiale</label></div>
                    </div>
                </div>
                <div class="group-box" style="border-left: 3px solid #ff3333;">
                    <div style="font-weight:bold; color:#ffcccc;">Terme Rayonnement (1/R)</div>
                    <div class="sub-group">
                        <div class="row"><input type="checkbox" id="chkRadRad" checked><span class="bar" style="background: #ff3333;"></span><label>Radiale</label></div>
                        <div class="row"><input type="checkbox" id="chkRadOrtho" checked><span class="bar" style="background: #ff8888; opacity:0.7;"></span><label>Orthoradiale</label></div>
                    </div>
                </div>
                
                 <div class="group-box" style="margin-top:10px; border:1px solid #ffff00;">
                     <div class="row"><span class="bar" style="background: #ffff00; height:4px;"></span><label style="color: #ffff00; font-weight:bold;">Champ Total E (Résultant)</label></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="scope-container">
        <div id="scope-header">
            <span id="scopeTitle">Signal à l'Observateur</span>
            <div>
                <span class="legend-item" style="color:#FFFF00;">E</span>
                <span class="legend-item" style="color:#00CCFF;">B</span>
                <span class="legend-item" style="color:#00FF00;">S</span>
            </div>
        </div>
        <canvas id="scopeCanvas"></canvas>
    </div>

    <canvas id="simCanvas"></canvas>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    const controls = document.getElementById('controls');
    const toggleBtn = document.getElementById('toggle-btn');
    const nSlider = document.getElementById('nSlider'); const nValue = document.getElementById('nValue');
    const betaSlider = document.getElementById('betaSlider'); const betaValue = document.getElementById('betaValue');
    const autoControls = document.getElementById('autoControls');
    
    const btnZoomIn = document.getElementById('btnZoomIn');
    const btnZoomOut = document.getElementById('btnZoomOut');

    const geoRingBtn = document.getElementById('geoRing'); const geoWireBtn = document.getElementById('geoWire');
    const modeAutoBtn = document.getElementById('modeAuto'); const modeManualBtn = document.getElementById('modeManual');
    const manualHint = document.getElementById('manualHint');
    
    let geometry = 'ring'; 
    let isManualMode = false;

    const chkShowScope = document.getElementById('chkShowScope'); 
    const scopeContainer = document.getElementById('scope-container');
    const scopeTitle = document.getElementById('scopeTitle');

    const chkPauseTrace = document.getElementById('chkPauseTrace');
    const chkFieldMap = document.getElementById('chkFieldMap');
    const chkMagneticMap = document.getElementById('chkMagneticMap'); 
    const chkPoynting = document.getElementById('chkPoynting');
    
    const chkCoulombRad = document.getElementById('chkCoulombRad');
    const chkCoulombOrtho = document.getElementById('chkCoulombOrtho');
    const chkRadRad = document.getElementById('chkRadRad');
    const chkRadOrtho = document.getElementById('chkRadOrtho');
    
    const chkShowReal = document.getElementById('chkShowReal');
    const chkShowRetarded = document.getElementById('chkShowRetarded');
    const chkShowVirtual = document.getElementById('chkShowVirtual');

    // SCOPE VARS
    const scopeCanvas = document.getElementById('scopeCanvas');
    const scopeCtx = scopeCanvas.getContext('2d');
    let scopeData = { E: [], B: [], S: [] };
    let scopeMax = { E: 0.0001, B: 0.0001, S: 0.0001 };
    const SCOPE_LEN = 150;

    let width, height;
    const c = 6;            
    const R_PHY = 40; 
    const K_BASE_REF = 4000;
    const amp = 0.25; 
    let freq = 0.03; 
    let targetBeta = 0.30; 
    
    let visualZoom = 3.5; 

    // MOUSE & PROBE
    let mouse = { x: 0, y: 0 };
    let probe = { x: 60, y: 0 }; 

    let N = 150; 
    let particles = [];
    let histories = []; 
    const MAX_HISTORY = 600; 
    let globalTime = 0;
    let lineSeeds = [];

    let manualCharge = { x: 0, y: 0, vx: 0, vy: 0 };

    toggleBtn.addEventListener('click', () => {
        controls.classList.toggle('collapsed');
        toggleBtn.textContent = controls.classList.contains('collapsed') ? '▶' : '◀';
    });

    function changeZoom(delta) {
        visualZoom += delta;
        if(visualZoom < 0.1) visualZoom = 0.1; 
        if(visualZoom > 15.0) visualZoom = 15.0;
        initLineSeeds(); 
        updateURL();
    }
    btnZoomIn.addEventListener('click', () => changeZoom(0.5));
    btnZoomOut.addEventListener('click', () => changeZoom(-0.5));

    chkShowScope.addEventListener('change', () => {
        scopeContainer.style.display = chkShowScope.checked ? 'flex' : 'none';
        updateURL();
    });

    function updateMode() {
        isManualMode = modeManualBtn.checked;
        if(isManualMode) {
            autoControls.classList.add('disabled-section');
            manualHint.style.display = 'block';
            N = 1; 
            probe.x = 60; probe.y = 0; 
            scopeTitle.textContent = "Signal à l'Observateur (Centre)";
        } else {
            autoControls.classList.remove('disabled-section');
            manualHint.style.display = 'none';
            N = parseInt(nSlider.value);
            scopeTitle.textContent = "Signal à la Souris";
        }
        initParticles();
        updateURL();
    }
    modeAutoBtn.addEventListener('change', updateMode);
    modeManualBtn.addEventListener('change', updateMode);

    function updateFreq() { freq = (targetBeta * c) / (R_PHY * amp); }

    nSlider.addEventListener('input', function() { if(!isManualMode) { N = parseInt(this.value); nValue.textContent = N; initParticles(); updateURL(); } });
    betaSlider.addEventListener('input', function() { targetBeta = parseFloat(this.value); betaValue.textContent = targetBeta.toFixed(2); updateFreq(); updateURL(); });

    geoRingBtn.addEventListener('change', () => { if(geoRingBtn.checked) { geometry = 'ring'; initParticles(); updateURL(); } });
    geoWireBtn.addEventListener('change', () => { if(geoWireBtn.checked) { geometry = 'wire'; initParticles(); updateURL(); } });

    [chkShowReal, chkShowRetarded, chkShowVirtual, chkCoulombRad, chkCoulombOrtho, chkRadRad, chkRadOrtho, chkPoynting, chkFieldMap, chkMagneticMap, chkPauseTrace].forEach(chk => {
        if(chk) chk.addEventListener('change', () => { updateUIVisibility(chk); updateURL(); });
    });

    function updateUIVisibility(source) {
        if (source === chkPauseTrace && chkPauseTrace.checked) {
            chkFieldMap.checked = false; chkMagneticMap.checked = false; chkPoynting.checked = false;
        } else if ((source === chkFieldMap || source === chkMagneticMap || source === chkPoynting) && (chkFieldMap.checked || chkMagneticMap.checked || chkPoynting.checked)) {
            chkPauseTrace.checked = false;
        }
        let anyMap = chkFieldMap.checked || chkMagneticMap.checked || chkPoynting.checked;
        boxPauseTrace.classList.toggle('disabled-section', !chkPauseTrace.checked && anyMap);
        boxFieldMap.classList.toggle('disabled-section', chkPauseTrace.checked);
        boxMagneticMap.classList.toggle('disabled-section', chkPauseTrace.checked);
        boxPoynting.classList.toggle('disabled-section', chkPauseTrace.checked);
    }
    
    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        scopeCanvas.width = 320; scopeCanvas.height = 155; 
        initLineSeeds();
    }
    window.addEventListener('resize', resize); resize();

    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left - width / 2;
        mouse.y = e.clientY - rect.top - height / 2;
    });

    function updateURL() {
        const params = new URLSearchParams();
        params.set('beta', betaSlider.value);
        params.set('n', nSlider.value);
        params.set('z', visualZoom.toFixed(2));
        params.set('geo', geometry);
        params.set('mode', isManualMode ? 'manual' : 'auto');
        params.set('scope', chkShowScope.checked ? '1' : '0');
        params.set('lines', chkPauseTrace.checked ? '1' : '0');
        params.set('emap', chkFieldMap.checked ? '1' : '0');
        params.set('bmap', chkMagneticMap.checked ? '1' : '0');
        params.set('smap', chkPoynting.checked ? '1' : '0');
        params.set('real', chkShowReal.checked ? '1' : '0');
        params.set('ret', chkShowRetarded.checked ? '1' : '0');
        params.set('virt', chkShowVirtual.checked ? '1' : '0');
        params.set('crad', chkCoulombRad.checked ? '1' : '0');
        params.set('corth', chkCoulombOrtho.checked ? '1' : '0');
        params.set('rrad', chkRadRad.checked ? '1' : '0');
        params.set('rorth', chkRadOrtho.checked ? '1' : '0');
        window.history.replaceState({}, '', `${location.pathname}?${params}`);
    }

    function loadFromURL() {
        const params = new URLSearchParams(window.location.search);
        if(!params.has('beta')) return; 
        
        if(params.has('beta')) { let val = parseFloat(params.get('beta')); betaSlider.value = val; targetBeta = val; betaValue.textContent = val.toFixed(2); }
        if(params.has('n')) { let val = parseInt(params.get('n')); nSlider.value = val; N = val; nValue.textContent = val; }
        if(params.has('z')) { let val = parseFloat(params.get('z')); visualZoom = val; }
        
        if(params.has('geo')) { let g = params.get('geo'); if(g === 'wire') { geoWireBtn.checked = true; geometry = 'wire'; } else { geoRingBtn.checked = true; geometry = 'ring'; } }
        
        if(params.has('mode')) {
            let m = params.get('mode');
            if(m === 'manual') { modeManualBtn.checked = true; isManualMode = true; }
            else { modeAutoBtn.checked = true; isManualMode = false; }
            updateMode(); 
        }

        if(params.has('scope')) { 
            chkShowScope.checked = (params.get('scope') === '1'); 
            scopeContainer.style.display = chkShowScope.checked ? 'flex' : 'none';
        }

        if(params.has('lines')) chkPauseTrace.checked = (params.get('lines') === '1');
        if(params.has('emap')) chkFieldMap.checked = (params.get('emap') === '1');
        if(params.has('bmap')) chkMagneticMap.checked = (params.get('bmap') === '1');
        if(params.has('smap')) chkPoynting.checked = (params.get('smap') === '1');
        
        if(params.has('real')) chkShowReal.checked = (params.get('real') === '1');
        if(params.has('ret')) chkShowRetarded.checked = (params.get('ret') === '1');
        if(params.has('virt')) chkShowVirtual.checked = (params.get('virt') === '1');
        
        if(params.has('crad')) chkCoulombRad.checked = (params.get('crad') === '1');
        if(params.has('corth')) chkCoulombOrtho.checked = (params.get('corth') === '1');
        if(params.has('rrad')) chkRadRad.checked = (params.get('rrad') === '1');
        if(params.has('rorth')) chkRadOrtho.checked = (params.get('rorth') === '1');
    }

    updateFreq(); loadFromURL(); initParticles(); initLineSeeds(); updateUIVisibility();

    function initParticles() {
        particles = []; histories = []; 
        scopeData = { E:[], B:[], S:[] }; scopeMax = { E: 0.0001, B: 0.0001, S: 0.0001 };
        manualCharge = { x: 0, y: 0, vx: 0, vy: 0 };

        if (isManualMode) {
            particles.push({ mode: 'manual', x:0, y:0, vx:0, vy:0, ax:0, ay:0 });
            histories.push([]);
        } else {
            if (geometry === 'ring') {
                for(let i=0; i<N; i++) {
                    let baseAngle = (Math.PI * 2 * i) / N;
                    particles.push({ mode: 'ring', baseAngle: baseAngle, phaseOffset: 0, x:0, y:0, vx:0, vy:0, ax:0, ay:0 });
                    histories.push([]); 
                }
            } else {
                for(let i=0; i<N; i++) {
                    let t = (N > 1) ? i / (N - 1) : 0.5; 
                    let baseY = -R_PHY + t * (2 * R_PHY);
                    particles.push({ mode: 'wire', baseY: baseY, phaseOffset: 0, x:0, y:0, vx:0, vy:0, ax:0, ay:0 });
                    histories.push([]);
                }
            }
        }
    }

    function updatePhysics() {
        globalTime++;
        if(particles.length === 0) return;

        if (isManualMode) {
            let p = particles[0];
            let tx = mouse.x / visualZoom;
            let ty = mouse.y / visualZoom;
            let smooth = 0.15;
            let nextX = p.x + (tx - p.x) * smooth;
            let nextY = p.y + (ty - p.y) * smooth;
            let newVx = nextX - p.x; 
            let newVy = nextY - p.y;
            let vMag = Math.sqrt(newVx*newVx + newVy*newVy);
            let limit = c * 0.95; 
            if(vMag > limit) {
                newVx = (newVx / vMag) * limit;
                newVy = (newVy / vMag) * limit;
                nextX = p.x + newVx;
                nextY = p.y + newVy;
            }
            p.ax = newVx - p.vx; p.ay = newVy - p.vy;
            p.vx = newVx; p.vy = newVy;
            p.x = nextX; p.y = nextY;
            histories[0].unshift({ x: p.x, y: p.y, vx: p.vx, vy: p.vy, ax: p.ax, ay: p.ay, t: globalTime });
            if (histories[0].length > MAX_HISTORY) histories[0].pop();
            return;
        }

        for(let i=0; i<N; i++) {
            let p = particles[i];
            if (p.mode === 'ring') {
                let phase = globalTime * freq + p.phaseOffset;
                let theta = p.baseAngle + amp * Math.sin(phase);
                let thetaDot = amp * freq * Math.cos(phase);
                let thetaDotDot = -amp * freq * freq * Math.sin(phase);
                let cosT = Math.cos(theta); let sinT = Math.sin(theta);
                p.x = R_PHY * cosT; p.y = R_PHY * sinT;
                p.vx = -R_PHY * sinT * thetaDot; p.vy =  R_PHY * cosT * thetaDot;
                p.ax = -R_PHY * (cosT * thetaDot * thetaDot + sinT * thetaDotDot);
                p.ay =  R_PHY * (-sinT * thetaDot * thetaDot + cosT * thetaDotDot);
            } else {
                let phase = globalTime * freq + p.phaseOffset;
                let spatialAmp = (c * targetBeta) / freq; 
                if (spatialAmp > R_PHY * 0.8) spatialAmp = R_PHY * 0.8;
                let osc = spatialAmp * Math.sin(phase);
                let vel = spatialAmp * freq * Math.cos(phase);
                let acc = -spatialAmp * freq * freq * Math.sin(phase);
                p.x = 0; p.y = p.baseY + osc;
                p.vx = 0; p.vy = vel;
                p.ax = 0; p.ay = acc;
            }
            histories[i].unshift({ x: p.x, y: p.y, vx: p.vx, vy: p.vy, ax: p.ax, ay: p.ay, t: globalTime });
            if (histories[i].length > MAX_HISTORY) histories[i].pop();
        }
    }

    function initLineSeeds() {
        lineSeeds = [];
        const cols = 25; const rows = 20;
        for(let i=0; i<cols; i++) {
            for(let j=0; j<rows; j++) {
                let jx = (Math.random()-0.5) * 40; let jy = (Math.random()-0.5) * 40;
                lineSeeds.push({ x: (i/cols - 0.5) * width * 1.4 + jx, y: (j/rows - 0.5) * height * 1.4 + jy });
            }
        }
    }

    function sub(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
    function mag(v) { return Math.sqrt(v.x * v.x + v.y * v.y); }
    function normalize(v) { let m = mag(v); return m === 0 ? {x:0, y:0} : { x: v.x/m, y: v.y/m }; }
    function dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }

    function getRetardedState(particleIndex, obsX, obsY) {
        if (!histories[particleIndex]) return null;
        let hist = histories[particleIndex];
        if (hist.length === 0) return null;
        let searchLimit = Math.min(hist.length, 600);
        let physX = obsX / visualZoom;
        let physY = obsY / visualZoom;
        for (let k = 0; k < searchLimit; k++) {
            let s = hist[k];
            let dx = physX - s.x; let dy = physY - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (Math.abs(dist - k * c) < c) return { state: s, R: dist, vectorR: {x: dx, y: dy} };
        }
        return null;
    }

    function computeFieldAt(x, y) {
        let res = { total: {x:0, y:0}, coulomb: {x:0, y:0}, rad: {x:0, y:0}, Bz: 0, count: 0 };
        let gammaApprox = 1 / Math.sqrt(1 - targetBeta*targetBeta);
        let visualK = K_BASE_REF * (150/40) * 1.5 / (gammaApprox * 0.5 + 0.5); 
        for(let i=0; i<N; i++) {
            let ret = getRetardedState(i, x, y); 
            if (ret) {
                res.count++;
                let s = ret.state; let R = ret.R;
                if(R < 2) R = 2; // CLAMP FOR SINGULARITY
                let n = normalize(ret.vectorR);
                let beta = { x: s.vx / c, y: s.vy / c }; let betaDot = { x: s.ax / c, y: s.ay / c }; 
                let kappa = 1 - dot(n, beta); if(kappa < 0.01) kappa = 0.01;
                let n_minus_beta = sub(n, beta);
                let coeff1 = visualK / (Math.pow(kappa, 3) * Math.pow(R, 2));
                let cx = n_minus_beta.x * coeff1; let cy = n_minus_beta.y * coeff1;
                let term2Vec = { x: 0, y: 0 };
                let AC = dot(n, betaDot); let AB = dot(n, n_minus_beta);
                term2Vec.x = n_minus_beta.x * AC - betaDot.x * AB;
                term2Vec.y = n_minus_beta.y * AC - betaDot.y * AB;
                let coeff2 = visualK / (c * Math.pow(kappa, 3) * R);
                let rx = term2Vec.x * coeff2; let ry = term2Vec.y * coeff2;
                let Ex_i = cx + rx; let Ey_i = cy + ry;
                res.coulomb.x += cx; res.coulomb.y += cy;
                res.rad.x += rx; res.rad.y += ry;
                res.total.x += Ex_i; res.total.y += Ey_i;
                let Bz_i = (1/c) * (n.x * Ey_i - n.y * Ex_i);
                res.Bz += Bz_i;
            }
        }
        return res;
    }

    function getFilteredVector(field, x, y) {
        if(field.count === 0) return {x:0, y:0};
        let u_r = {x:0, y:0}, u_theta = {x:0, y:0};
        let dist = Math.sqrt(x*x + y*y);
        if(dist > 0.001) { u_r.x = x / dist; u_r.y = y / dist; u_theta.x = -u_r.y; u_theta.y = u_r.x; }
        window.u_r = u_r; window.u_theta = u_theta; 
        let finalVec = {x:0, y:0};
        if(chkCoulombRad.checked) { let val = dot(field.coulomb, u_r); finalVec.x += val * u_r.x; finalVec.y += val * u_r.y; }
        if(chkCoulombOrtho.checked) { let val = dot(field.coulomb, u_theta); finalVec.x += val * u_theta.x; finalVec.y += val * u_theta.y; }
        if(chkRadRad.checked) { let val = dot(field.rad, u_r); finalVec.x += val * u_r.x; finalVec.y += val * u_r.y; }
        if(chkRadOrtho.checked) { let val = dot(field.rad, u_theta); finalVec.x += val * u_theta.x; finalVec.y += val * u_theta.y; }
        return finalVec;
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, lineWidth, opacity = 1.0, isOutline = false) {
        if (!isFinite(toX) || !isFinite(toY)) return;
        const dx = toX - fromX; const dy = toY - fromY; const len = Math.sqrt(dx*dx + dy*dy); if (len < 2) return;
        const headLength = 8 + lineWidth; const angle = Math.atan2(dy, dx); const headAngle = Math.PI / 9; 
        ctx.save(); ctx.globalAlpha = opacity; 
        if (isOutline) {
            ctx.strokeStyle = "#000000"; ctx.fillStyle = "#000000"; ctx.lineWidth = lineWidth + 2.5;
            ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - headAngle), toY - headLength * Math.sin(angle - headAngle));
            ctx.lineTo(toX - headLength * Math.cos(angle + headAngle), toY - headLength * Math.sin(angle + headAngle));
            ctx.closePath(); ctx.fill(); ctx.stroke();
        } 
        
        ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = lineWidth;
        ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - headAngle), toY - headLength * Math.sin(angle - headAngle));
        ctx.lineTo(toX - headLength * Math.cos(angle + headAngle), toY - headLength * Math.sin(angle + headAngle));
        ctx.closePath(); ctx.fill();
        ctx.restore();
    }

    function drawScope(eVal, bVal, sVal) {
        scopeData.E.push(eVal); if(scopeData.E.length > SCOPE_LEN) scopeData.E.shift();
        scopeData.B.push(bVal); if(scopeData.B.length > SCOPE_LEN) scopeData.B.shift();
        scopeData.S.push(sVal); if(scopeData.S.length > SCOPE_LEN) scopeData.S.shift();
        scopeMax.E = Math.max(scopeMax.E, eVal); scopeMax.B = Math.max(scopeMax.B, bVal); scopeMax.S = Math.max(scopeMax.S, sVal);
        scopeCtx.fillStyle = '#000'; scopeCtx.fillRect(0, 0, scopeCanvas.width, scopeCanvas.height);
        function drawLine(arr, color, maxVal) {
            scopeCtx.beginPath(); scopeCtx.strokeStyle = color; scopeCtx.lineWidth = 2;
            let step = scopeCanvas.width / SCOPE_LEN;
            for(let i=0; i<arr.length; i++) {
                let x = i * step;
                let y = scopeCanvas.height - (arr[i] / maxVal) * (scopeCanvas.height * 0.9) - 5;
                if(i===0) scopeCtx.moveTo(x, y); else scopeCtx.lineTo(x, y);
            }
            scopeCtx.stroke();
        }
        drawLine(scopeData.E, '#FFFF00', scopeMax.E);
        drawLine(scopeData.B, '#00CCFF', scopeMax.B);
        drawLine(scopeData.S, '#00FF00', scopeMax.S);
    }

    function drawContinuousStreamlines() {
        ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(255, 230, 150, 0.6)'; 
        const MAX_STEPS = 200; const STEP_SIZE = 8; ctx.beginPath();
        for (let seed of lineSeeds) {
            let pointsForward = []; let cx = seed.x, cy = seed.y; pointsForward.push({x: cx, y: cy});
            for(let k=0; k<MAX_STEPS; k++) {
                let rawField = computeFieldAt(cx, cy); 
                let v = getFilteredVector(rawField, cx, cy);
                let mag = Math.sqrt(v.x*v.x + v.y*v.y); 
                if(mag < 0.00001) break; 
                cx += (v.x / mag) * STEP_SIZE; cy += (v.y / mag) * STEP_SIZE;
                if(Math.abs(cx) > width/1.6 || Math.abs(cy) > height/1.6 || Math.sqrt(cx*cx + cy*cy) < 20) break; 
                pointsForward.push({x: cx, y: cy});
            }
            let pointsBackward = []; cx = seed.x; cy = seed.y;
            for(let k=0; k<MAX_STEPS; k++) {
                let rawField = computeFieldAt(cx, cy); 
                let v = getFilteredVector(rawField, cx, cy);
                let mag = Math.sqrt(v.x*v.x + v.y*v.y); 
                if(mag < 0.00001) break;
                cx -= (v.x / mag) * STEP_SIZE; cy -= (v.y / mag) * STEP_SIZE;
                if(Math.abs(cx) > width/1.6 || Math.abs(cy) > height/1.6 || Math.sqrt(cx*cx + cy*cy) < 20) break;
                pointsBackward.push({x: cx, y: cy});
            }
            if(pointsBackward.length > 0) {
                let start = pointsBackward[pointsBackward.length-1]; ctx.moveTo(start.x, start.y);
                for(let i=pointsBackward.length-2; i>=0; i--) ctx.lineTo(pointsBackward[i].x, pointsBackward[i].y);
                ctx.lineTo(seed.x, seed.y); 
            } else { ctx.moveTo(seed.x, seed.y); }
            for(let i=1; i<pointsForward.length; i++) ctx.lineTo(pointsForward[i].x, pointsForward[i].y);
        }
        ctx.stroke();
    }

    function draw() {
        try {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillRect(0, 0, width, height);
            ctx.save(); ctx.translate(width / 2, height / 2);
            if (!chkPauseTrace.checked) updatePhysics();
            ctx.globalAlpha = 1.0; ctx.setLineDash([]);
            
            if (!isManualMode) {
                if (geometry === 'ring') {
                    let oscAngle = amp * Math.sin(globalTime * freq);
                    ctx.beginPath();
                    let bx = (R_PHY * visualZoom) * Math.cos(oscAngle); 
                    let by = (R_PHY * visualZoom) * Math.sin(oscAngle);
                    ctx.moveTo(-bx, -by); ctx.lineTo(bx, by);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 4; ctx.stroke();
                    ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fillStyle = '#FFF'; ctx.fill();
                } else {
                    let spatialAmp = (c * targetBeta) / freq; if(spatialAmp > R_PHY*0.8) spatialAmp = R_PHY*0.8;
                    let oscY = (spatialAmp * visualZoom) * Math.sin(globalTime * freq);
                    ctx.beginPath(); ctx.arc(0, oscY, 4, 0, Math.PI*2); ctx.fillStyle = '#FFF'; ctx.fill();
                }
            } else {
                let p = particles[0];
                ctx.beginPath(); ctx.arc(p.x * visualZoom, p.y * visualZoom, 4, 0, Math.PI*2);
                ctx.fillStyle = '#FFF'; ctx.fill();
            }

            let safeN = Math.max(N, 1); 
            const step = 20; 
            const B_SCALE_FACTOR = 800 / Math.sqrt(safeN); 
            const MAX_ARROW_LEN = step * 0.95;
            const MAX_S_LEN = step * 0.9;

            // UNIFIED GRID LOOP (Centered Offset)
            // Offset ensures we never hit (0,0) exactly
            // Increase loop range by +2 to cover full screen
            const nX = Math.ceil(width / 2 / step) + 2;
            const nY = Math.ceil(height / 2 / step) + 2;

            for (let i = -nX; i <= nX; i++) {
                for (let j = -nY; j <= nY; j++) {
                    // CENTERED OFFSET: (i + 0.5) * step
                    let x = (i + 0.5) * step;
                    let y = (j + 0.5) * step;
                    
                    let field = computeFieldAt(x, y); 
                    
                    // 1. MAGNETIC
                    if (chkMagneticMap.checked) {
                        let Bz = field.Bz;
                        let intensity = Math.tanh(Bz * B_SCALE_FACTOR / 60); let absI = Math.abs(intensity);
                        if (absI > 0.02) {
                            let radius = absI * (step * 0.4); radius = Math.max(radius, 1.0);
                            ctx.fillStyle = (Bz > 0) ? 'rgba(255, 200, 0, 0.5)' : 'rgba(0, 200, 255, 0.5)';
                            ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); 
                        }
                    }

                    // 2. ELECTRIC
                    if (chkFieldMap.checked) {
                        let v = getFilteredVector(field, x, y);
                        let mag = Math.sqrt(v.x*v.x + v.y*v.y);
                        if (mag > 0.00005) {
                            let magPerCharge = mag / safeN;
                            let intensity = Math.log(1 + magPerCharge * 500); 
                            let ratio = intensity / 4.0; if(ratio > 1) ratio = 1;
                            let len = ratio * MAX_ARROW_LEN;
                            let w = 1 + 2 * (len / MAX_ARROW_LEN); 
                            if(len > 3) {
                                let dx = (v.x/mag) * len; let dy = (v.y/mag) * len;
                                let isBg = (chkMagneticMap.checked || chkPoynting.checked);
                                drawArrow(ctx, x - dx/2, y - dy/2, x + dx/2, y + dy/2, '#FFFFFF', w, 0.8, isBg);
                            }
                        }
                    }

                    // 3. POYNTING
                    if (chkPoynting.checked) {
                        let Sx = field.total.y * field.Bz;
                        let Sy = -field.total.x * field.Bz;
                        let Smag = Math.sqrt(Sx*Sx + Sy*Sy);
                        if (Smag > 0.000001) {
                            let SmagRoot = Math.sqrt(Smag);
                            let normalizedS = SmagRoot / safeN; 
                            let intensity = Math.log(1 + normalizedS * 500); 
                            let ratio = intensity / 4.0; if(ratio > 1) ratio = 1;
                            let len = ratio * MAX_S_LEN;
                            let w = 0.5 + 1.0 * (len / MAX_S_LEN);
                            if (len > 3) {
                                let dx = (Sx/Smag) * len; let dy = (Sy/Smag) * len;
                                let isBg = (chkMagneticMap.checked || chkFieldMap.checked);
                                drawArrow(ctx, x - dx/2, y - dy/2, x + dx/2, y + dy/2, '#00FF00', w, 0.9, isBg);
                            }
                        }
                    }
                }
            }

            if (chkPauseTrace.checked) drawContinuousStreamlines();

            if ((chkShowReal.checked || chkShowRetarded.checked || chkShowVirtual.checked)) {
                if(particles.length === N) {
                    for(let i=0; i<N; i++) {
                        let p = particles[i];
                        if(chkShowReal.checked) { 
                            ctx.fillStyle = '#666'; ctx.beginPath(); 
                            ctx.arc(p.x * visualZoom, p.y * visualZoom, 3, 0, Math.PI*2); ctx.fill(); 
                        }
                        if(!chkPauseTrace.checked) {
                            let obsX = isManualMode ? (probe.x * visualZoom) : mouse.x;
                            let obsY = isManualMode ? (probe.y * visualZoom) : mouse.y;
                            if(chkShowRetarded.checked || chkShowVirtual.checked) {
                                let ret = getRetardedState(i, obsX, obsY);
                                if(ret) {
                                    if(chkShowRetarded.checked) { 
                                        ctx.fillStyle = 'cyan'; ctx.beginPath(); 
                                        ctx.arc(ret.state.x * visualZoom, ret.state.y * visualZoom, 2, 0, Math.PI*2); ctx.fill(); 
                                    }
                                    if(chkShowVirtual.checked) { 
                                        let dt = ret.R / c; 
                                        let virtX = ret.state.x + ret.state.vx * dt;
                                        let virtY = ret.state.y + ret.state.vy * dt;
                                        ctx.fillStyle = 'magenta'; ctx.beginPath(); 
                                        ctx.arc(virtX * visualZoom, virtY * visualZoom, 1.5, 0, Math.PI*2); ctx.fill(); 
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if (chkShowScope.checked) {
                let obsX = isManualMode ? (probe.x * visualZoom) : mouse.x;
                let obsY = isManualMode ? (probe.y * visualZoom) : mouse.y;
                if(isFinite(obsX) && isFinite(obsY)) {
                    let field = computeFieldAt(obsX, obsY); 
                    try {
                        let eMag = Math.sqrt(field.total.x**2 + field.total.y**2);
                        let bMag = Math.abs(field.Bz);
                        let sMag = eMag * bMag;
                        drawScope(eMag, bMag, sMag); 
                    } catch(err) {}
                }
            }

            // TOTAL VECTOR DRAWING (ONLY IN AUTO MODE)
            if (!isManualMode) {
                let obsX = mouse.x;
                let obsY = mouse.y;
                if (isFinite(obsX) && isFinite(obsY)) {
                    let field = computeFieldAt(obsX, obsY);
                    let v_filtered = getFilteredVector(field, obsX, obsY); 
                    if (field.count > 0) {
                        let displayScale = 40 * Math.sqrt(10/safeN); 
                        
                        let v_C_rad = { x: dot(field.coulomb, u_r) * u_r.x * displayScale, y: dot(field.coulomb, u_r) * u_r.y * displayScale };
                        let v_C_orth = { x: dot(field.coulomb, u_theta) * u_theta.x * displayScale, y: dot(field.coulomb, u_theta) * u_theta.y * displayScale };
                        let v_R_rad = { x: dot(field.rad, u_r) * u_r.x * displayScale, y: dot(field.rad, u_r) * u_r.y * displayScale };
                        let v_R_orth = { x: dot(field.rad, u_theta) * u_theta.x * displayScale, y: dot(field.rad, u_theta) * u_theta.y * displayScale };
                        
                        // Only draw components if NOT manual mode
                        if (!isManualMode) {
                            if (chkCoulombRad.checked) drawArrow(ctx, obsX, obsY, obsX + v_C_rad.x, obsY + v_C_rad.y, '#00ff00', 1.5, 0.9);
                            if (chkCoulombOrtho.checked) drawArrow(ctx, obsX, obsY, obsX + v_C_orth.x, obsY + v_C_orth.y, '#66ff66', 1.5, 0.9);
                            if (chkRadRad.checked) drawArrow(ctx, obsX, obsY, obsX + v_R_rad.x, obsY + v_R_rad.y, '#ff3333', 1.5, 0.9);
                            if (chkRadOrtho.checked) drawArrow(ctx, obsX, obsY, obsX + v_R_orth.x, obsY + v_R_orth.y, '#ff8888', 1.5, 0.9);
                        }

                        // TOTAL VECTOR
                        let v_sum = { x: v_filtered.x * displayScale, y: v_filtered.y * displayScale };
                        let vSumLen = Math.sqrt(v_sum.x**2 + v_sum.y**2);
                        if (vSumLen > 0.001) {
                            drawArrow(ctx, obsX, obsY, obsX + v_sum.x, obsY + v_sum.y, '#FFFF00', 2.5, 1.0);
                        }
                    }
                }
            }
            
            ctx.restore();
        } catch(e) {
            console.error("Erreur de rendu (ignorée) : ", e);
            ctx.restore();
        }
        requestAnimationFrame(draw);
    }
    
    function getFilteredVector(field, x, y) {
        if(field.count === 0) return {x:0, y:0};
        let u_r = {x:0, y:0}, u_theta = {x:0, y:0};
        let dist = Math.sqrt(x*x + y*y);
        if(dist > 0.001) { u_r.x = x / dist; u_r.y = y / dist; u_theta.x = -u_r.y; u_theta.y = u_r.x; }
        window.u_r = u_r; window.u_theta = u_theta; 
        let finalVec = {x:0, y:0};
        if(chkCoulombRad.checked) { let val = dot(field.coulomb, u_r); finalVec.x += val * u_r.x; finalVec.y += val * u_r.y; }
        if(chkCoulombOrtho.checked) { let val = dot(field.coulomb, u_theta); finalVec.x += val * u_theta.x; finalVec.y += val * u_theta.y; }
        if(chkRadRad.checked) { let val = dot(field.rad, u_r); finalVec.x += val * u_r.x; finalVec.y += val * u_r.y; }
        if(chkRadOrtho.checked) { let val = dot(field.rad, u_theta); finalVec.x += val * u_theta.x; finalVec.y += val * u_theta.y; }
        return finalVec;
    }

    draw();
</script>
</body>
</html>
