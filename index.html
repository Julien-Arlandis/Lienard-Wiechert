<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Liénard-Wiechert v2.0 : Logarithmique & Overlay</title>
    
    <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
      svg: { fontCache: 'global' }
    };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; }
        canvas { display: block; }
        
        #controls { 
            position: absolute; top: 10px; left: 10px; 
            width: 340px; 
            z-index: 10;
            transition: transform 0.3s ease-in-out;
            overflow: visible; 
            pointer-events: none;
        }

        #controls.collapsed { transform: translateX(-360px); }

        #panel-content {
            background: rgba(20, 20, 20, 0.95); 
            padding: 12px; 
            border: 1px solid #555; 
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.9);
            max-height: 95vh; 
            overflow-y: auto;
            pointer-events: auto;
            font-size: 12px;
            scrollbar-width: thin; scrollbar-color: #555 #222;
            position: relative;
        }

        .version-tag {
            position: absolute; top: 8px; right: 12px;
            font-family: monospace; font-size: 10px; color: #666; pointer-events: none;
        }

        #toggle-btn {
            position: absolute; top: 0; right: -32px; width: 32px; height: 32px;
            background: #333; color: #fff; border: 1px solid #555; border-left: none;
            border-radius: 0 6px 6px 0; cursor: pointer; pointer-events: auto;
            display: flex; align-items: center; justify-content: center; font-size: 16px;
        }
        #toggle-btn:hover { background: #444; color: #00aaff; }

        #panel-content::-webkit-scrollbar { width: 8px; }
        #panel-content::-webkit-scrollbar-track { background: #222; border-radius: 4px; }
        #panel-content::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }

        #equation-box {
            margin-bottom: 15px; padding: 10px 5px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid #444; border-radius: 6px;
            text-align: center; color: #ddd;
        }
        
        .eq-title { font-weight:bold; color:#aaa; font-size:11px; margin-top:8px; margin-bottom:2px; text-transform:uppercase; letter-spacing:1px; }

        h3 { margin-top: 0; margin-bottom: 10px; color: #eee; font-size: 15px; text-align: center; line-height: 1.4; margin-right: 20px; }
        hr { border: 0; border-top: 1px solid #555; margin: 10px 0; }

        input[type=range] { vertical-align: middle; cursor: pointer; width: 100%; margin: 5px 0; }
        label { color: #ccc; cursor: pointer; }
        .group-box { margin-top: 8px; background: rgba(255,255,255,0.05); padding: 5px; border-radius: 5px; border: 1px solid #444; }
        .sub-group { margin-left: 15px; border-left: 2px solid #555; padding-left: 5px; margin-top: 2px; }
        .row { display: flex; align-items: center; margin-bottom: 3px; position: relative; }
        input[type=checkbox] { margin-right: 6px; transform: scale(1.0); cursor: pointer; }
        .dot { height: 8px; width: 8px; border-radius: 50%; display: inline-block; margin-right: 8px; flex-shrink: 0; }
        .bar { height: 3px; width: 20px; display: inline-block; margin-right: 8px; border-radius: 2px; }
        .val { color: #fff; font-weight: bold; }
        mjx-container { font-size: 85% !important; color: #eee !important; overflow-x: hidden; margin: 2px 0 !important; }

        .info-label { border-bottom: 1px dotted #888; cursor: help; }
        .tooltip {
            visibility: hidden; width: 260px; background-color: #111; color: #eee; text-align: left; 
            border-radius: 6px; padding: 12px; position: absolute; z-index: 100; top: 100%; left: 10px; 
            margin-top: 5px; border: 1px solid #444; border-left: 3px solid #00aaff;
            box-shadow: 0 5px 20px rgba(0,0,0,1); opacity: 0; transition: opacity 0.3s; 
            font-size: 11px; line-height: 1.5; pointer-events: none;
        }
        .row:hover .tooltip { visibility: visible; opacity: 1; }
        .tooltip strong { color: #00aaff; display: block; margin-bottom: 5px; font-size: 12px; border-bottom: 1px solid #333; padding-bottom: 3px; }
        .tooltip em { color: #aaa; display: block; margin-top: 5px; font-style: italic; }
        
        .disabled-section { opacity: 0.3; pointer-events: none; transition: opacity 0.3s; }
        
        .symbol-legend { display: flex; justify-content: center; gap: 20px; margin-top: 5px; font-size: 11px; color: #ccc; }
        .sym { font-weight: bold; font-size: 14px; display: inline-block; width: 15px; text-align: center; }
        .gradient-legend {
            height: 12px; width: 100%; margin-top: 5px; border-radius: 2px; margin-bottom: 2px;
            background: linear-gradient(to right, #00ffff, #0000aa, #000000, #aa0000, #ffff00);
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="toggle-btn" title="Réduire/Agrandir le panneau">◀</button>

        <div id="panel-content">
            <div class="version-tag">v2.0 (Log)</div>

            <h3>Champ de Liénard-Wiechert :<br>Notation Physique $\odot / \otimes$</h3>
            
            <div id="equation-box">
                <div class="eq-title">1. Formule de Liénard-Wiechert</div>
                $$ \vec{E} = \frac{q}{4\pi\epsilon_0} \left[ \underbrace{ \color{#00ff00}{ \frac{\vec{n} - \vec{\beta}}{\gamma^2 \kappa^3 R^2} } }_{\text{Coulomb}} + \underbrace{ \color{#ff3333}{ \frac{\vec{n} \times [(\vec{n} - \vec{\beta}) \times \dot{\vec{\beta}}]}{c \kappa^3 R} } }_{\text{Rayonnement}} \right]_{ret} $$
                
                <div style="margin: 8px 0; border-top: 1px dashed #555;"></div>
                
                <div class="eq-title">2. Formule de Heaviside-Feynman</div>
                $$ E = \frac{q}{4\pi\epsilon_0} \left[ \underbrace{ \color{#00ff00}{ \frac{e_{r'}}{r'^2} + \frac{r'}{c} \frac{d}{dt} \left( \frac{e_{r'}}{r'^2} \right) } }_{\text{Coulomb}} + \underbrace{ \color{#ff3333}{ \frac{1}{c^2} \frac{d^2}{dt^2} e_{r'} } }_{\text{Rayonnement}} \right] $$
            </div>
            
            <hr>

            <label for="rSlider" style="color:#ffcc00;">Zoom / Rayon de l'anneau : <span id="rValue" class="val">150</span></label><br>
            <input type="range" id="rSlider" min="15" max="200" step="5" value="150">
            
            <label for="betaSlider" style="margin-top:5px; display:block;">Vitesse des charges (&beta;=v/c) : <span id="betaValue" class="val">0.30</span></label>
            <input type="range" id="betaSlider" min="0.1" max="0.95" step="0.01" value="0.30">
            
            <label for="nSlider" style="margin-top:2px; display:block;">Nombre de charges : <span id="nValue" class="val">150</span></label>
            <input type="range" id="nSlider" min="1" max="350" value="150">

            <hr>
            <div style="font-weight:bold; color:#eee; margin-bottom:5px; text-align:center;">MODES DE VISUALISATION</div>

            <div class="group-box" id="boxPauseTrace" style="border: 1px solid #ffcc00; background:rgba(50,50,0,0.3);">
                <div class="row">
                    <input type="checkbox" id="chkPauseTrace">
                    <label for="chkPauseTrace" style="color:#ffcc00; font-weight:bold;">Visualiser les lignes de champ (E)</label>
                </div>
                <div style="font-size:10px; color:#aaa; margin-left:20px;">(Pause l'animation, mode exclusif)</div>
            </div>

            <div class="group-box" id="boxMagneticMap" style="border: 1px solid #aaa; margin-top:5px; background:rgba(0,0,50,0.3);">
                <div class="row">
                    <input type="checkbox" id="chkMagneticMap">
                    <label for="chkMagneticMap" style="color:#ccc; font-weight:bold;">Carte B ($\odot / \otimes$)</label>
                </div>
                <div class="symbol-legend">
                    <div><span class="sym" style="color:#00ffff;">&#8855;</span> Entrant</div>
                    <div><span class="sym" style="color:#ffff00;">&#8857;</span> Sortant</div>
                </div>
            </div>

            <div class="group-box" id="boxFieldMap" style="border: 1px solid #aaa; margin-top:5px;">
                <div class="row">
                    <input type="checkbox" id="chkFieldMap">
                    <label for="chkFieldMap" style="color:#ccc; font-weight:bold;">Carte vectorielle du champ E</label>
                </div>
                <div style="font-size:10px; color:#aaa; margin-left:20px;">(Flèches proportionnelles log)</div>
            </div>

            <hr>
            
            <div class="group-box">
                <div style="font-weight:bold; color:#bbb; margin-bottom:3px;">Position des charges :</div>
                
                <div class="row">
                    <input type="checkbox" id="chkShowReal" checked>
                    <span class="dot" style="background:#888;"></span>
                    <label for="chkShowReal" class="info-label">Réelle (t)</label>
                    <div class="tooltip">
                        <strong>Charge Réelle (Présent)</strong>
                        Position physique exacte de la particule à l'instant actuel $t$.<br>
                        <em>Note : L'information que la particule est ici n'a pas encore eu le temps d'arriver à l'observateur.</em>
                    </div>
                </div>
                
                <div class="row">
                    <input type="checkbox" id="chkShowRetarded">
                    <span class="dot" style="background:cyan;"></span>
                    <label for="chkShowRetarded" class="info-label">Retardée (t')</label>
                    <div class="tooltip">
                        <strong>Charge Retardée (Passé)</strong>
                        Position de la particule au temps passé $t' = t - R/c$.<br>
                        C'est de cet endroit qu'est partie l'onde électromagnétique que l'observateur reçoit maintenant.
                    </div>
                </div>
                
                <div class="row">
                    <input type="checkbox" id="chkShowVirtual" checked>
                    <span class="dot" style="background:magenta;"></span>
                    <label for="chkShowVirtual" class="info-label">Virtuelle</label>
                    <div class="tooltip">
                        <strong>Charge Virtuelle (Extrapolée)</strong>
                        Position qu'aurait la charge <strong>maintenant</strong> si elle avait continué tout droit à vitesse constante.<br>
                        <em>Physique : Le champ électrique "proche" pointe vers cette position.</em>
                    </div>
                </div>
            </div>

            <div id="vectorOptions" style="margin-top:10px;">
                <div style="font-weight:bold; color:#ffffaa; margin-bottom:3px; text-align:center; font-size:11px;">FILTRAGE DES COMPOSANTES (E)</div>
                
                <div class="group-box" style="border-left: 3px solid #00ff00;">
                    <div style="font-weight:bold; color:#ccffcc;">Terme Coulomb (1/R²)</div>
                    <div class="sub-group">
                        <div class="row"><input type="checkbox" id="chkCoulombRad" checked><span class="bar" style="background: #00ff00;"></span><label>Radiale</label></div>
                        <div class="row"><input type="checkbox" id="chkCoulombOrtho" checked><span class="bar" style="background: #66ff66; opacity:0.7;"></span><label>Orthoradiale</label></div>
                    </div>
                </div>
                
                <div class="group-box" style="border-left: 3px solid #ff3333;">
                    <div style="font-weight:bold; color:#ffcccc;">Terme Rayonnement (1/R)</div>
                    <div class="sub-group">
                        <div class="row"><input type="checkbox" id="chkRadRad" checked><span class="bar" style="background: #ff3333;"></span><label>Radiale</label></div>
                        <div class="row"><input type="checkbox" id="chkRadOrtho" checked><span class="bar" style="background: #ff8888; opacity:0.7;"></span><label>Orthoradiale</label></div>
                    </div>
                </div>
                
                <div id="trailBox" class="group-box">
                     <div class="row"><span class="bar" style="background: #ffff00; height:4px;"></span><label style="color: #ffff00;">Champ Total E (Souris)</label></div>
                    <div class="row" style="margin-top:5px; border-top:1px solid #555; padding-top:5px;">
                        <input type="checkbox" id="chkShowTrail" checked>
                        <label for="chkShowTrail" style="font-style:italic;">Afficher la trace (Hodographe)</label>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <canvas id="simCanvas"></canvas>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const controls = document.getElementById('controls');
    const toggleBtn = document.getElementById('toggle-btn');
    
    const nSlider = document.getElementById('nSlider'); const nValue = document.getElementById('nValue');
    const betaSlider = document.getElementById('betaSlider'); const betaValue = document.getElementById('betaValue');
    const rSlider = document.getElementById('rSlider'); const rValue = document.getElementById('rValue');
    
    const chkPauseTrace = document.getElementById('chkPauseTrace');
    const boxPauseTrace = document.getElementById('boxPauseTrace');
    const chkFieldMap = document.getElementById('chkFieldMap');
    const boxFieldMap = document.getElementById('boxFieldMap');
    const chkMagneticMap = document.getElementById('chkMagneticMap'); 
    const boxMagneticMap = document.getElementById('boxMagneticMap'); 
    
    const chkCoulombRad = document.getElementById('chkCoulombRad');
    const chkCoulombOrtho = document.getElementById('chkCoulombOrtho');
    const chkRadRad = document.getElementById('chkRadRad');
    const chkRadOrtho = document.getElementById('chkRadOrtho');
    
    const chkShowReal = document.getElementById('chkShowReal');
    const chkShowRetarded = document.getElementById('chkShowRetarded');
    const chkShowVirtual = document.getElementById('chkShowVirtual');
    
    const chkShowTrail = document.getElementById('chkShowTrail'); 
    const trailBox = document.getElementById('trailBox');

    let width, height;

    const c = 6;            
    let R_ring = 150; 
    const K_BASE_REF = 4000;
    const amp = 0.25; 

    let freq = 0.03; 
    let targetBeta = 0.30; 

    let mouse = { x: 0, y: 0 };
    let N = 150; 
    let particles = [];
    let histories = []; 
    const MAX_HISTORY = 600; 
    let globalTime = 0;
    
    let vectorTrail = []; 
    const MAX_TRAIL_LENGTH = 150; 

    let lineSeeds = [];

    // --- BOUTON PANEL ---
    toggleBtn.addEventListener('click', () => {
        controls.classList.toggle('collapsed');
        toggleBtn.textContent = controls.classList.contains('collapsed') ? '▶' : '◀';
    });

    // --- URL ---
    function updateURL() {
        const params = new URLSearchParams();
        params.set('beta', betaSlider.value); params.set('n', nSlider.value); params.set('r', rSlider.value);
        params.set('lines', chkPauseTrace.checked ? '1' : '0');
        params.set('emap', chkFieldMap.checked ? '1' : '0');
        params.set('bmap', chkMagneticMap.checked ? '1' : '0');
        params.set('real', chkShowReal.checked ? '1' : '0');
        params.set('ret', chkShowRetarded.checked ? '1' : '0');
        params.set('virt', chkShowVirtual.checked ? '1' : '0');
        params.set('crad', chkCoulombRad.checked ? '1' : '0');
        params.set('corth', chkCoulombOrtho.checked ? '1' : '0');
        params.set('rrad', chkRadRad.checked ? '1' : '0');
        params.set('rorth', chkRadOrtho.checked ? '1' : '0');
        window.history.replaceState({}, '', `${location.pathname}?${params}`);
    }

    function loadFromURL() {
        const params = new URLSearchParams(window.location.search);
        if(!params.has('beta')) return; 
        if(params.has('beta')) { let val = parseFloat(params.get('beta')); betaSlider.value = val; targetBeta = val; betaValue.textContent = val.toFixed(2); }
        if(params.has('n')) { let val = parseInt(params.get('n')); nSlider.value = val; N = val; nValue.textContent = val; }
        if(params.has('r')) { let val = parseInt(params.get('r')); rSlider.value = val; R_ring = val; rValue.textContent = val; }
        if(params.has('lines')) chkPauseTrace.checked = (params.get('lines') === '1');
        if(params.has('emap')) chkFieldMap.checked = (params.get('emap') === '1');
        if(params.has('bmap')) chkMagneticMap.checked = (params.get('bmap') === '1');
        if(params.has('real')) chkShowReal.checked = (params.get('real') === '1');
        if(params.has('ret')) chkShowRetarded.checked = (params.get('ret') === '1');
        if(params.has('virt')) chkShowVirtual.checked = (params.get('virt') === '1');
        if(params.has('crad')) chkCoulombRad.checked = (params.get('crad') === '1');
        if(params.has('corth')) chkCoulombOrtho.checked = (params.get('corth') === '1');
        if(params.has('rrad')) chkRadRad.checked = (params.get('rrad') === '1');
        if(params.has('rorth')) chkRadOrtho.checked = (params.get('rorth') === '1');
    }

    function initParticles() {
        particles = []; histories = []; vectorTrail = [];
        for(let i=0; i<N; i++) {
            let baseAngle = (Math.PI * 2 * i) / N;
            particles.push({ baseAngle: baseAngle, phaseOffset: 0, x: 0, y: 0, vx: 0, vy: 0, ax: 0, ay: 0 });
            histories.push([]); 
        }
    }

    function initLineSeeds() {
        lineSeeds = [];
        const cols = 25; const rows = 20;
        for(let i=0; i<cols; i++) {
            for(let j=0; j<rows; j++) {
                let jx = (Math.random()-0.5) * 40; let jy = (Math.random()-0.5) * 40;
                lineSeeds.push({ x: (i/cols - 0.5) * width * 1.4 + jx, y: (j/rows - 0.5) * height * 1.4 + jy });
            }
        }
    }

    function updateFreq() { freq = (targetBeta * c) / (R_ring * amp); }

    nSlider.addEventListener('input', function() { N = parseInt(this.value); nValue.textContent = N; initParticles(); updateURL(); });
    betaSlider.addEventListener('input', function() { targetBeta = parseFloat(this.value); betaValue.textContent = targetBeta.toFixed(2); updateFreq(); updateURL(); });
    rSlider.addEventListener('input', function() { R_ring = parseInt(this.value); rValue.textContent = R_ring; updateFreq(); updateURL(); });

    [chkShowReal, chkShowRetarded, chkShowVirtual, chkCoulombRad, chkCoulombOrtho, chkRadRad, chkRadOrtho].forEach(chk => {
        chk.addEventListener('change', updateURL);
    });

    function updateUIVisibility(source) {
        if (source === chkPauseTrace && chkPauseTrace.checked) {
            chkFieldMap.checked = false; chkMagneticMap.checked = false;
        } else if ((source === chkFieldMap || source === chkMagneticMap) && (chkFieldMap.checked || chkMagneticMap.checked)) {
            chkPauseTrace.checked = false;
        }
        boxPauseTrace.classList.toggle('disabled-section', !chkPauseTrace.checked && (chkFieldMap.checked || chkMagneticMap.checked));
        boxFieldMap.classList.toggle('disabled-section', chkPauseTrace.checked);
        boxMagneticMap.classList.toggle('disabled-section', chkPauseTrace.checked);
        if(!chkPauseTrace.checked && !chkFieldMap.checked && !chkMagneticMap.checked) { trailBox.style.display = 'block'; } else { trailBox.style.display = 'none'; }
        updateURL();
    }
    
    chkPauseTrace.addEventListener('change', () => updateUIVisibility(chkPauseTrace));
    chkFieldMap.addEventListener('change', () => updateUIVisibility(chkFieldMap));
    chkMagneticMap.addEventListener('change', () => updateUIVisibility(chkMagneticMap));
    
    function resize() {
        width = window.innerWidth; height = window.innerHeight;
        canvas.width = width; canvas.height = height;
        initLineSeeds();
    }
    window.addEventListener('resize', resize); resize();

    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left - width / 2;
        mouse.y = e.clientY - rect.top - height / 2;
        vectorTrail = []; 
    });

    loadFromURL(); 
    updateFreq(); initParticles(); initLineSeeds(); updateUIVisibility();

    function updatePhysics() {
        globalTime++;
        for(let i=0; i<N; i++) {
            let p = particles[i];
            let phase = globalTime * freq + p.phaseOffset;
            let theta = p.baseAngle + amp * Math.sin(phase);
            let thetaDot = amp * freq * Math.cos(phase);
            let thetaDotDot = -amp * freq * freq * Math.sin(phase);
            let cosT = Math.cos(theta); let sinT = Math.sin(theta);
            p.x = R_ring * cosT; p.y = R_ring * sinT;
            p.vx = -R_ring * sinT * thetaDot; p.vy =  R_ring * cosT * thetaDot;
            p.ax = -R_ring * (cosT * thetaDot * thetaDot + sinT * thetaDotDot);
            p.ay =  R_ring * (-sinT * thetaDot * thetaDot + cosT * thetaDotDot);
            histories[i].unshift({ x: p.x, y: p.y, vx: p.vx, vy: p.vy, ax: p.ax, ay: p.ay, t: globalTime });
            if (histories[i].length > MAX_HISTORY) histories[i].pop();
        }
    }

    function sub(v1, v2) { return { x: v1.x - v2.x, y: v1.y - v2.y }; }
    function mag(v) { return Math.sqrt(v.x * v.x + v.y * v.y); }
    function normalize(v) { let m = mag(v); return m === 0 ? {x:0, y:0} : { x: v.x/m, y: v.y/m }; }
    function dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }

    function getRetardedState(particleIndex, obsX, obsY) {
        let hist = histories[particleIndex];
        if (!hist || hist.length === 0) return null;
        let searchLimit = Math.min(hist.length, 600);
        for (let k = 0; k < searchLimit; k++) {
            let s = hist[k];
            let dx = obsX - s.x; let dy = obsY - s.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (Math.abs(dist - k * c) < c) return { state: s, R: dist, vectorR: {x: dx, y: dy} };
        }
        return null;
    }

    function computeFieldAt(x, y) {
        let res = { total: {x:0, y:0}, coulomb: {x:0, y:0}, rad: {x:0, y:0}, Bz: 0, count: 0 };
        let gammaApprox = 1 / Math.sqrt(1 - targetBeta*targetBeta);
        let zoomFactor = 150 / R_ring; 
        let visualK = K_BASE_REF * zoomFactor * 1.5 / (gammaApprox * 0.5 + 0.5); 

        for(let i=0; i<N; i++) {
            let ret = getRetardedState(i, x, y);
            if (ret) {
                res.count++;
                let s = ret.state; let R = ret.R; let n = normalize(ret.vectorR);
                let beta = { x: s.vx / c, y: s.vy / c }; let betaDot = { x: s.ax / c, y: s.ay / c }; 
                let kappa = 1 - dot(n, beta); if(kappa < 0.01) kappa = 0.01;
                let n_minus_beta = sub(n, beta);
                let coeff1 = visualK / (Math.pow(kappa, 3) * Math.pow(R, 2));
                let cx = n_minus_beta.x * coeff1; let cy = n_minus_beta.y * coeff1;
                let term2Vec = { x: 0, y: 0 };
                let AC = dot(n, betaDot); let AB = dot(n, n_minus_beta);
                term2Vec.x = n_minus_beta.x * AC - betaDot.x * AB;
                term2Vec.y = n_minus_beta.y * AC - betaDot.y * AB;
                let coeff2 = visualK / (c * Math.pow(kappa, 3) * R);
                let rx = term2Vec.x * coeff2; let ry = term2Vec.y * coeff2;
                let Ex_i = cx + rx; let Ey_i = cy + ry;
                res.coulomb.x += cx; res.coulomb.y += cy;
                res.rad.x += rx; res.rad.y += ry;
                res.total.x += Ex_i; res.total.y += Ey_i;
                let Bz_i = (1/c) * (n.x * Ey_i - n.y * Ex_i);
                res.Bz += Bz_i;
            }
        }
        return res;
    }

    function getFilteredVector(field, x, y) {
        if(field.count === 0) return {x:0, y:0};
        let u_r = {x:0, y:0}, u_theta = {x:0, y:0};
        let dist = Math.sqrt(x*x + y*y);
        if(dist > 0.001) { u_r.x = x / dist; u_r.y = y / dist; u_theta.x = -u_r.y; u_theta.y = u_r.x; }
        let finalVec = {x:0, y:0};
        if(chkCoulombRad.checked) { let val = dot(field.coulomb, u_r); finalVec.x += val * u_r.x; finalVec.y += val * u_r.y; }
        if(chkCoulombOrtho.checked) { let val = dot(field.coulomb, u_theta); finalVec.x += val * u_theta.x; finalVec.y += val * u_theta.y; }
        if(chkRadRad.checked) { let val = dot(field.rad, u_r); finalVec.x += val * u_r.x; finalVec.y += val * u_r.y; }
        if(chkRadOrtho.checked) { let val = dot(field.rad, u_theta); finalVec.x += val * u_theta.x; finalVec.y += val * u_theta.y; }
        return finalVec;
    }

    function drawArrow(ctx, fromX, fromY, toX, toY, color, lineWidth, opacity = 1.0) {
        if (!isFinite(toX) || !isFinite(toY)) return;
        const dx = toX - fromX; const dy = toY - fromY; const len = Math.sqrt(dx*dx + dy*dy); if (len < 2) return;
        const headLength = 8 + lineWidth; const angle = Math.atan2(dy, dx); const headAngle = Math.PI / 9; 
        
        ctx.save(); ctx.globalAlpha = opacity; 
        
        if(chkMagneticMap.checked) {
            ctx.strokeStyle = "#000000";
            ctx.fillStyle = "#000000";
            ctx.lineWidth = lineWidth + 2.5; 
            ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - headAngle), toY - headLength * Math.sin(angle - headAngle));
            ctx.lineTo(toX - headLength * Math.cos(angle + headAngle), toY - headLength * Math.sin(angle + headAngle));
            ctx.closePath(); ctx.fill(); ctx.stroke();
        }

        ctx.strokeStyle = color;
        ctx.fillStyle = color;
        ctx.lineWidth = lineWidth;

        ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(toX, toY);
        ctx.lineTo(toX - headLength * Math.cos(angle - headAngle), toY - headLength * Math.sin(angle - headAngle));
        ctx.lineTo(toX - headLength * Math.cos(angle + headAngle), toY - headLength * Math.sin(angle + headAngle));
        ctx.closePath(); ctx.fill();

        ctx.restore();
    }

    function drawContinuousStreamlines() {
        ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(255, 230, 150, 0.6)'; 
        const MAX_STEPS = 200; const STEP_SIZE = 8; ctx.beginPath();
        for (let seed of lineSeeds) {
            let pointsForward = []; let cx = seed.x, cy = seed.y; pointsForward.push({x: cx, y: cy});
            for(let k=0; k<MAX_STEPS; k++) {
                let rawField = computeFieldAt(cx, cy); let v = getFilteredVector(rawField, cx, cy);
                let mag = Math.sqrt(v.x*v.x + v.y*v.y); if(mag < 0.0001) break;
                cx += (v.x / mag) * STEP_SIZE; cy += (v.y / mag) * STEP_SIZE;
                if(Math.abs(cx) > width/1.6 || Math.abs(cy) > height/1.6 || Math.sqrt(cx*cx + cy*cy) < 20) break; 
                pointsForward.push({x: cx, y: cy});
            }
            let pointsBackward = []; cx = seed.x; cy = seed.y;
            for(let k=0; k<MAX_STEPS; k++) {
                let rawField = computeFieldAt(cx, cy); let v = getFilteredVector(rawField, cx, cy);
                let mag = Math.sqrt(v.x*v.x + v.y*v.y); if(mag < 0.0001) break;
                cx -= (v.x / mag) * STEP_SIZE; cy -= (v.y / mag) * STEP_SIZE;
                if(Math.abs(cx) > width/1.6 || Math.abs(cy) > height/1.6 || Math.sqrt(cx*cx + cy*cy) < 20) break;
                pointsBackward.push({x: cx, y: cy});
            }
            if(pointsBackward.length > 0) {
                let start = pointsBackward[pointsBackward.length-1]; ctx.moveTo(start.x, start.y);
                for(let i=pointsBackward.length-2; i>=0; i--) ctx.lineTo(pointsBackward[i].x, pointsBackward[i].y);
                ctx.lineTo(seed.x, seed.y); 
            } else { ctx.moveTo(seed.x, seed.y); }
            for(let i=1; i<pointsForward.length; i++) ctx.lineTo(pointsForward[i].x, pointsForward[i].y);
        }
        ctx.stroke();
    }

    function draw() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; ctx.fillRect(0, 0, width, height);
        ctx.save(); ctx.translate(width / 2, height / 2);
        if (!chkPauseTrace.checked) updatePhysics();
        ctx.globalAlpha = 1.0; ctx.setLineDash([]);
        let oscAngle = amp * Math.sin(globalTime * freq);
        ctx.beginPath();
        let bx = R_ring * Math.cos(oscAngle); let by = R_ring * Math.sin(oscAngle);
        ctx.moveTo(-bx, -by); ctx.lineTo(bx, by);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 4; ctx.stroke();
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fillStyle = '#FFF'; ctx.fill();

        if (chkMagneticMap.checked) {
            const step = 40; 
            const startX = -Math.floor(width/2 / step) * step; const endX = Math.ceil(width/2 / step) * step;
            const startY = -Math.floor(height/2 / step) * step; const endY = Math.ceil(height/2 / step) * step;
            const B_SCALE_FACTOR = 800 / Math.sqrt(N); 
            for (let x = startX; x <= endX; x += step) {
                for (let y = startY; y <= endY; y += step) {
                    let field = computeFieldAt(x, y); let Bz = field.Bz;
                    let intensity = Math.tanh(Bz * B_SCALE_FACTOR / 60); let absI = Math.abs(intensity);
                    if (absI > 0.02) {
                        let radius = absI * (step * 0.4); radius = Math.max(radius, 1.0);
                        ctx.strokeStyle = (Bz > 0) ? '#ffcc00' : '#00ccff'; ctx.lineWidth = 1.2;
                        ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.stroke(); 
                        if (Bz > 0) { ctx.fillStyle = '#ffcc00'; ctx.beginPath(); ctx.arc(x, y, 1.5, 0, Math.PI*2); ctx.fill(); }
                        else { let r = radius * 0.6; ctx.beginPath(); ctx.moveTo(x - r, y - r); ctx.lineTo(x + r, y + r); ctx.moveTo(x + r, y - r); ctx.lineTo(x - r, y + r); ctx.stroke(); }
                    }
                }
            }
        }

        if (chkFieldMap.checked) {
            const step = 40; 
            const startX = -Math.floor(width/2 / step) * step; const endX = Math.ceil(width/2 / step) * step;
            const startY = -Math.floor(height/2 / step) * step; const endY = Math.ceil(height/2 / step) * step;
            const MAX_ARROW_LEN = step * 0.95;
            const saturationK = 0.002 * N; 

            for (let x = startX; x <= endX; x += step) {
                for (let y = startY; y <= endY; y += step) {
                    let rawField = computeFieldAt(x, y); let v = getFilteredVector(rawField, x, y);
                    let mag = Math.sqrt(v.x*v.x + v.y*v.y);
                    
                    if (mag > 0.00005) {
                        let normalizedIntensity = mag / (N * 0.01); 
                        let intensityColor = Math.log(normalizedIntensity * 300 + 1) / 5; 
                        if(intensityColor > 1) intensityColor = 1;
                        let hue = 240 - intensityColor * 180; let light = 30 + intensityColor * 60;
                        let col = `hsl(${hue}, 100%, ${light}%)`;
                        
                        // LOGARITHMIC LENGTH
                        // Utilisation du Log pour gérer la dynamique extrême
                        let len = Math.log(mag * 10000 + 1) * 3;
                        len = Math.min(len, MAX_ARROW_LEN);
                        
                        if(len > 2) {
                            let dx = (v.x/mag) * len; let dy = (v.y/mag) * len;
                            drawArrow(ctx, x - dx/2, y - dy/2, x + dx/2, y + dy/2, col, 1.5, 1.0);
                        }
                    }
                }
            }
        }

        if (chkPauseTrace.checked) drawContinuousStreamlines();

        if ((chkShowReal.checked || chkShowRetarded.checked || chkShowVirtual.checked)) {
            for(let i=0; i<N; i++) {
                let p = particles[i];
                if(chkShowReal.checked) { ctx.fillStyle = '#666'; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); }
                if(!chkPauseTrace.checked) {
                    if(chkShowRetarded.checked || chkShowVirtual.checked) {
                        let ret = getRetardedState(i, mouse.x, mouse.y);
                        if(ret) {
                            if(chkShowRetarded.checked) { ctx.fillStyle = 'cyan'; ctx.beginPath(); ctx.arc(ret.state.x, ret.state.y, 2, 0, Math.PI*2); ctx.fill(); }
                            if(chkShowVirtual.checked) { let dt = ret.R / c; ctx.fillStyle = 'magenta'; ctx.beginPath(); ctx.arc(ret.state.x + ret.state.vx * dt, ret.state.y + ret.state.vy * dt, 1.5, 0, Math.PI*2); ctx.fill(); }
                        }
                    }
                }
            }
        }
        
        // --- OVERLAY SOURIS TOUJOURS ACTIF ---
        let field = computeFieldAt(mouse.x, mouse.y); let v_filtered = getFilteredVector(field, mouse.x, mouse.y); 
        if (field.count > 0) {
            let mouseDist = Math.sqrt(mouse.x*mouse.x + mouse.y*mouse.y);
            let u_r = { x: 0, y: 0 }; let u_theta = { x: 0, y: 0 };
            if (mouseDist > 0.1) { u_r.x = mouse.x / mouseDist; u_r.y = mouse.y / mouseDist; u_theta.x = -u_r.y; u_theta.y = u_r.x; }
            let scaleFactor = N > 10 ? Math.sqrt(10/N) : 1; let displayScale = 40 * scaleFactor; 
            let v_C_rad = { x: dot(field.coulomb, u_r) * u_r.x * displayScale, y: dot(field.coulomb, u_r) * u_r.y * displayScale };
            let v_C_orth = { x: dot(field.coulomb, u_theta) * u_theta.x * displayScale, y: dot(field.coulomb, u_theta) * u_theta.y * displayScale };
            let v_R_rad = { x: dot(field.rad, u_r) * u_r.x * displayScale, y: dot(field.rad, u_r) * u_r.y * displayScale };
            let v_R_orth = { x: dot(field.rad, u_theta) * u_theta.x * displayScale, y: dot(field.rad, u_theta) * u_theta.y * displayScale };
            
            if (chkCoulombRad.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_C_rad.x, mouse.y + v_C_rad.y, '#00ff00', 1.5, 0.9);
            if (chkCoulombOrtho.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_C_orth.x, mouse.y + v_C_orth.y, '#66ff66', 1.5, 0.9);
            if (chkRadRad.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_R_rad.x, mouse.y + v_R_rad.y, '#ff3333', 1.5, 0.9);
            if (chkRadOrtho.checked) drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_R_orth.x, mouse.y + v_R_orth.y, '#ff8888', 1.5, 0.9);

            let v_sum = { x: v_filtered.x * displayScale, y: v_filtered.y * displayScale };
            let vSumLen = Math.sqrt(v_sum.x**2 + v_sum.y**2);
            if (vSumLen > 0.001) {
                if (chkShowTrail.checked) {
                    vectorTrail.push({x: mouse.x + v_sum.x, y: mouse.y + v_sum.y});
                    if (vectorTrail.length > MAX_TRAIL_LENGTH) vectorTrail.shift();
                    ctx.beginPath();
                    for(let k=0; k<vectorTrail.length - 1; k++) { ctx.moveTo(vectorTrail[k].x, vectorTrail[k].y); ctx.lineTo(vectorTrail[k+1].x, vectorTrail[k+1].y); }
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)'; ctx.lineWidth = 1; ctx.stroke();
                }
                if (vSumLen > 15) { drawArrow(ctx, mouse.x, mouse.y, mouse.x + v_sum.x, mouse.y + v_sum.y, '#ffff00', 2, 1.0); }
                else { let dirX = v_sum.x / vSumLen; let dirY = v_sum.y / vSumLen; ctx.save(); ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(mouse.x, mouse.y); ctx.lineTo(mouse.x + dirX * 60, mouse.y + dirY * 60); ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)'; ctx.lineWidth = 2; ctx.stroke(); ctx.restore(); }
            }
        }
        
        ctx.restore();
        requestAnimationFrame(draw);
    }
    draw();
</script>
</body>
</html>
